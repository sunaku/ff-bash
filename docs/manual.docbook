<?xml version="1.0" encoding="utf-8"?>
<!--
	Copyright 2003, 2004, 2005 Suraj N. Kurapati.

	Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "GNU Free Documentation License".
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!ENTITY fdlAppendix SYSTEM "fdl.xml">

	<!ENTITY gnu "<acronym>GNU</acronym>">
	<!ENTITY unix "<acronym>UNIX</acronym>">
	<!ENTITY bash "&gnu; <acronym>BASH</acronym>">
	<!ENTITY url "<acronym>URL</acronym>">

	<!ENTITY ff "<application>For each File</application>">
	<!ENTITY cmd "ff">
	<!ENTITY website "http://ff-bash.sf.net">

	<!ENTITY period "period <literal>.</literal>">
	<!ENTITY noteNeedRecursiveOpt "<note><para>This option has no effect when used without the <option>--recursive</option> option.</para></note>">
	<!ENTITY abstract "This manual explains how to install, use, and extend <ulink url='&website;'>&ff;</ulink>.">
]>
<book lang="en">
	<bookinfo>
		<title>&ff; User's Manual</title>

		<author>
			<firstname>Suraj</firstname>
			<othername>N.</othername>
			<surname>Kurapati</surname>
		</author>

		<copyright>
			<year>2003</year>
			<year>2004</year>
			<year>2005</year>
			<holder>Suraj N. Kurapati</holder>
		</copyright>

		<abstract>
			<para>&abstract;</para>
		</abstract>

		<revhistory>
			<revision>
				<revnumber>1.2</revnumber>
				<date>2005-11-03</date>
				<authorinitials>snk</authorinitials>
				<revremark>Extensive refactoring of document structure and content.</revremark>
			</revision>

			<revision>
				<revnumber>1.1</revnumber>
				<date>2005-11-02</date>
				<authorinitials>snk</authorinitials>
				<revremark>Initial port of user manual from old script-based manualPages to DocBook-XML.</revremark>
			</revision>
		</revhistory>

		<legalnotice>
			<para>Permission is granted to copy, distribute and/or modify this document under the terms of the &gnu; Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included in the section entitled "&gnu; Free Documentation License".</para>
		</legalnotice>
	</bookinfo>

	<chapter id="chp:intro">
		<title>Introduction</title>

		<para>&abstract; However, it assumes that you have basic knowledge of:
			<itemizedlist>
				<listitem>
					<para>how to run commands using the &bash; shell.</para>
				</listitem>
				<listitem>
					<para>&unix; terminology such as "command-line", "command-prompt", "standard input stream", and so on.</para>
				</listitem>
				<listitem>
					<para>programming or software development terminology such as "string", "function", "variable", and so on.</para>
				</listitem>
				<listitem>
					<para>traditional &unix;-style manual pages and how they are organized.</para>
				</listitem>
			</itemizedlist>
		</para>

		<section id="sec:what-is-ff">
			<title>What is &ff;?</title>
			<para>&ff; is a &bash; function. It lets you run an arbitrary set of &bash; commands upon an arbitrary set of objects.</para>

			<para>&ff; is often used to perform repetitive file-system manipulation tasks such as renaming a large number of files. For example, you can easily rename the suffix of all gzipped tarballs in directory <filename>foo</filename> from <literal>tgz</literal> to <literal>tar.gz</literal> by running the command <command>&cmd; <option>-rme</option> <replaceable>foo</replaceable> <replaceable>'*tgz'</replaceable> <replaceable>'mv "$p" "${p%tgz}tar.gz"'</replaceable></command>.</para>
		</section>
	</chapter>

	<chapter id="chp:getting-started">
		<title>Getting Started</title>

		<section id="sec:requirements">
			<title>Requirements</title>
			<para/>
		</section>

		<section id="sec:installation">
			<title>Installing &ff;</title>
			<para/>
		</section>
	</chapter>

	<chapter id="chp:using">
		<title>Using &ff;</title>

		<procedure id="proc:using">
			<title>Using &ff;</title>

			<step performance="required">
				<para><link linkend="sec:invocation">Invoke &ff;</link> at a command-prompt.</para>
			</step>

			<step>
				<para>If you did not specify <link linkend="sec:writing-scripts">your script</link> in the previous step, then &ff; will give you a chance to <link linkend="ex:typing-script-at-prompt">type it at your command-prompt</link>.</para>

				<substeps>
					<step>
						<para>Type your script using as much space as you need. That is, your script can take up multiple lines. You can start a new line by pressing the <keycap>Enter</keycap> or <keycap>Return</keycap> key.</para>

						<tip>
							<title>&gnu; Readline Shortcuts</title>
							<para>While typing your script, you can use <ulink url="http://cnswww.cns.cwru.edu/~chet/readline/rltop.html">&gnu; Readline</ulink> shortcuts such as <keycombo action="press"><keycap>Ctrl</keycap><keycap>u</keycap></keycombo> to erase everything between the cursor and the beginning of a line; and <keycombo action="press"><keycap>Ctrl</keycap><keycap>k</keycap></keycombo> to erase everything between the cursor and the end of a line.</para>
						</tip>
					</step>

					<step>
						<para>Press <keycombo action="press"><keycap>Ctrl</keycap><keycap>d</keycap></keycombo> on a new, blank line to tell &ff; that you have finished typing your script.</para>
					</step>
				</substeps>
			</step>

			<step>
				<para>&ff; will now run your script, return a <!--TODO: link-->diagnostic value as its exit status, and terminate.</para>
			</step>
		</procedure>

		<example id="ex:typing-script-at-prompt">
					<title>Typing Your Script at a Command-Prompt</title>
					<screen>
<prompt>$</prompt> <userinput><command>&cmd; <replaceable>World</replaceable></command></userinput>
<userinput>echo -n "Hello, $o! Today is "
date
<keycombo action="press"><keycap>Ctrl</keycap><keycap>d</keycap></keycombo></userinput>
<computeroutput>Hello, World! Today is Thu Nov  3 15:32:16 PST 2005</computeroutput>
<prompt>$</prompt>
					</screen>
		</example>

		<section id="sec:invocation">
			<title>Invoking &ff;</title>
			<para> <!-- explain what the syntax means --></para>
		</section>

		<section id="sec:writing-scripts">
			<title>Writing Scripts</title>
			<para/>

			<section id="sec:control-functions">
				<title>Control Functions</title>
				<para/>
			</section>

			<section id="sec:object-variables">
				<title>Object Variables</title>
				<para/>
			</section>
		</section>
	</chapter>

	<chapter id="chp:extending">
		<title>Extending &ff;</title>
		<para/>

		<section id="sec:localization">
			<title>Localizing &ff;</title>
			<para/>
		</section>
	</chapter>

	<chapter id="chp:feedback">
		<title>Giving Feedback</title>
		<para/>

		<section id="sec:defect-reports">
			<title>Reporting Defects</title>
			<para/>
		</section>

		<section id="sec:feature-request">
			<title>Requesting Features</title>
			<para/>
		</section>

		<section id="sec:discussion-forums">
			<title>Voicing Your Opinion</title>
			<para/>
		</section>

		<section id="sec:getting-help">
			<title>Getting Help</title>
			<para/>
		</section>
	</chapter>

	<appendix>
		<title>Traditional &unix;-Style Manual Page</title>
		<refentry id="ref:manualPage">
			<refmeta>
				<refentrytitle>
					<application>&cmd;</application>
				</refentrytitle>
				<manvolnum>1</manvolnum>
			</refmeta>

			<refnamediv>
				<refname>
					<application>&cmd;</application>
				</refname>
				<refpurpose>Run &bash; commands on objects.</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<cmdsynopsis>
					<command>&cmd;</command>
					<group choice="opt">
						<arg choice="opt" rep="repeat">option</arg>
						<arg choice="opt" rep="repeat">object</arg>
					</group>
				</cmdsynopsis>

				<variablelist>
					<varlistentry>
						<term>option</term>
						<listitem>
							<para>A mechanism which lets you control how &ff; behaves. See <xref linkend="ref:options"/> for a list of available options.</para>

							<tip>
								<title>Combining Short Options</title>
								<para>You can combine a series of short options into a single option. For example, the series <command><option>-a</option> 1 <option>-b</option> 2 <option>-c</option> 3</command> can be combined into <command><option>-abc</option> 1 2 3</command>.</para>
							</tip>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>object</term>
						<listitem>
							<para>Something that is passed as an argument to your script for processing. &ff; places no restrcitions on what an object can represent. Thus, your script has complete authority in deciding the semantics of an object.
							</para>
							<para>For example, if your script renames files, then objects are files. Likewise, if your script downloads data from &url;s, then objects are &url;s.</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</refsynopsisdiv>

			<!--
			<refsection>
				<title>Description</title>
				<para>&desc;</para>
			</refsection>
			-->

			<refsection id="ref:options">
				<title>Options</title>
				<variablelist>
					<varlistentry>
						<term>
							<option>--</option>
						</term>
						<listitem>
							<para>Stop looking for options among the given arguments and consider that the remaining arguments are objects.</para>

							<para>With this option, you can safely specify objects whose names begin with a hyphen <literal>-</literal>. Such objects would otherwise be mistaken for options. For example, you can specify two objects named <option>-foo</option> and <option>-bar</option> by writing them as <command><option>--</option> <option>-foo</option> <option>-bar</option></command>.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-e</option>
							<replaceable>expression</replaceable>
						</term>
						<term>
							<option>--expression</option>
							<replaceable>expression</replaceable>
						</term>
						<listitem>
							<para>Consider that <replaceable>expression</replaceable> is the user's script instead of asking the the user to type a script at the command-prompt.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-f</option>
							<replaceable>file</replaceable>
						</term>
						<term>
							<option>--file</option>
							<replaceable>file</replaceable>
						</term>
						<listitem>
							<para>Consider that <replaceable>file</replaceable> contains the user's script instead of asking the user to type a script at the command-prompt.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-p</option>
						</term>
						<term>
							<option>--pipe</option>
						</term>
						<listitem>
							<para>Read the standard input stream for objects which are delimited by the new-line character. In other words, these objects should be listed one per line on the standard input stream.</para>

							<para>Objects specified as command-line arguments are processsed by your script before the objects specified on the standard input stream.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>--suffix-delim</option>
							<replaceable>delimiter</replaceable>
						</term>
						<listitem>
							<para>Consider that <replaceable>delimiter</replaceable> separates the <link linkend="ex:object-name-parts">prefix and suffix<footnote id="fot:suffix-and-extension">
								<para>The suffix is also called "extension" or "file extension".</para>
							</footnote></link> of an object's name. The default suffix delimiter is a &period;.</para>

							<example id="ex:object-name-parts">
								<title>The Parts of an Object's Name</title>
								<para>
									The name of an object called <filename>foo.bar.baz</filename> can be divided into the following parts:

									<itemizedlist>
										<listitem>
											<para>A prefix: <literal>foo.bar</literal></para>
										</listitem>
										<listitem>
											<para>A suffix delimiter: <literal>.</literal></para>
										</listitem>
										<listitem>
											<para>A suffix: <literal>bar</literal></para>
										</listitem>
									</itemizedlist>
								</para>
							</example>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-r</option>
						</term>
						<term>
							<option>--recursive</option>
						</term>
						<listitem>
							<para>Recursively traverse into objects, which happen to be directories or symbolic links that point to directories, in a <link linkend="ex:breadth-first-recursion">breadth-first manner</link>.</para>

							<example id="ex:breadth-first-recursion">
								<title>Order of Handling in Breadth-First Recursion</title>
								<para>When breadth-first recursion is used, all objects in a directory are processsed linearly by the user's script <emphasis>before</emphasis> any sub-directories are processsed recursively.</para>

								<para>For example, in the directory structure below, the objects <filename>foo/</filename> and <filename>bar/</filename> are directories. When &ff; is invoked to run your script recursively upon <filename>foo/</filename>, the objects <filename>foo/bar</filename> and <filename>foo/moz</filename> are processsed linearly by your script <emphasis>before</emphasis> <filename>foo/bar</filename> is processsed recursively. In this manner, <filename>foo/bar/baz</filename> will be the last object processsed by your script.</para>

								<itemizedlist>
									<listitem>
										<para><filename>foo/</filename></para>

										<itemizedlist>
											<listitem>
												<para><filename>bar/</filename></para>

												<itemizedlist>
													<listitem>
														<para><filename>baz</filename></para>
													</listitem>
												</itemizedlist>
											</listitem>

											<listitem>
												<para><filename>moz</filename></para>
											</listitem>
										</itemizedlist>
									</listitem>
								</itemizedlist>
							</example>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-a</option>
						</term>
						<term>
							<option>--all</option>
						</term>
						<listitem>
							<para>Do not ignore objects whose names begin with a &period;.</para>

							&noteNeedRecursiveOpt;
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-L</option>
						</term>
						<term>
							<option>--ignore-links</option>
						</term>
						<listitem>
							<para>Do not traverse into symbolic links that point to directories.</para>

							&noteNeedRecursiveOpt;
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-m</option>
							<replaceable>glob</replaceable>
						</term>
						<term>
							<option>--mask</option>
							<replaceable>glob</replaceable>
						</term>
						<listitem>
							<para>Handle objects only if their names match <replaceable>glob</replaceable><footnote id="fot:bash-glob">
								<para>See "Pattern Matching" in the &bash; manual for more information.</para>
							</footnote>.</para>

							<para>Unless the <option>--all</option> option is also specified, objects whose names begin with a &period; are not checked to see if their names match <replaceable>glob</replaceable>. For example, objects with names such as <filename>.foo</filename> and <filename>.bar</filename> will not not checked to see if they match <replaceable>glob</replaceable>, whereas objects with names such as <filename>foo</filename> and <filename>bar</filename> will be checked.</para>

							<para>If <replaceable>glob</replaceable> is a fixed string and does not use any globbing notation, then it will be appended to the name of every object that matches the <literal>*</literal> glob. This happens because &ff; does not check if an object exists in the file-system before having your script processs the object. For example, try running the command <command>&cmd; <option>-r</option> <replaceable>/etc</replaceable> <option>-m</option> <replaceable>globbyGlob</replaceable> <option>-e</option> <replaceable>'echo "$p"'</replaceable></command> and notice how all echoed paths have the word <literal>globbyGlob</literal> appended to them.</para>

							&noteNeedRecursiveOpt;

							<tip>
								<para>You can use extended<footnote id="fot:bash-extglob">
									<para>See "extglob" in the &bash; manual for more information.</para>
								</footnote> globbing notation in <replaceable>glob</replaceable>.</para>
							</tip>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-h</option>
						</term>
						<term>
							<option>--help</option>
						</term>
						<listitem>
							<para>Show the invocation syntax and a list of available options in extended<footnoteref linkend="fot:bash-extglob"/> globbing notation.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-v</option>
						</term>
						<term>
							<option>--verbose</option>
						</term>
						<listitem>
							<para>Describe what you are doing, while you do it.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term>
							<option>-V</option>
						</term>
						<term>
							<option>--version</option>
						</term>
						<listitem>
							<para>Show your release-version and copyright.</para>
						</listitem>
					</varlistentry>

				</variablelist>
			</refsection>
		</refentry>
	</appendix>

	&fdlAppendix;
</book>
