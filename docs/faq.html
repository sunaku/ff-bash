<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
	<head>
		<title>&quot;For each File&quot; &mdash; Frequently Asked Questions</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
		<link rel="stylesheet" type="text/css" href="style.css"/>
	</head>
	<body>
		<h1>&quot;For each File&quot; &mdash; Frequently Asked Questions</h1>
		<blockquote>
			<p>This document answers frequently asked questions about the &quot;For each File&quot; package. Visit the project web site at <a href="http://freshmeat.net/projects/ff/">http://freshmeat.net/projects/ff/</a> for the latest software updates, documentation, and additional resources.</p>
			<p>Copyright &copy; 2003, 2004 Suraj N. Kurapati.</p>
			<p>This file is part of "For each File".</p>
			<p>"For each File" is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p>
			<p>"For each File" is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>
			<p>You should have received a copy of the GNU General Public License along with "For each File"; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</p>
		</blockquote>

		<h2>Have a Question?</h2>
		<blockquote>
			<p>You can post your question on the project web site or send an e-mail to <samp>skurapat@ucsc.edu</samp>.</p>
		</blockquote>
		
		<h2>Questions and Answers</h2>
		<blockquote>
			<ol>
				<li>What are the advantages of using &quot;For each File&quot; instead of <samp>find -exec</samp>?
				<blockquote>
					<p>It should be noted that &quot;For each File&quot; behaves more like the <samp>xargs</samp> tool than <samp>find -exec</samp>, but is more robust in the commands it can execute. For example, <samp>xargs</samp> can execute a single command once for each piece of input it is given; whereas &quot;For each File&quot; can execute a series of <samp>BASH</samp> shell commands for each piece of the same input.</p>
					
					<p>Nevertheless, in comparison to using <samp>find -exec</samp>, key advantages of using &quot;For each File&quot; are as follows.</p>
					<ul>
						<li>Performance &mdash; <i>system resources are better utilized</i>.</li>
						<li>Flexibility &mdash; <i>the user can perform complex tasks without having to write a separate script</i>.</li>
						<li>Simplicity &mdash; <i>saves the user time and effort while increasing their productivity</i>.</li>
					</ul>
					<p>The following sections aim to justify these claims.</p>
					
					<h3>Performance of execution.</h3>
					<blockquote>
						<p>For every file it encounters, <samp>find -exec</samp> forks a separate child-process to execute the user's commands. On a large input size, this behavior yields poor performance. In contrast, this tool employs only one process (analogous to <samp>xargs</samp>) to execute the user's commands. Thus it uses less system resources and yields better performance.</p>
					</blockquote>
					
					<h3>Performing complex tasks.</h3>
					<blockquote>
						<p>One of the key ideas behind the &quot;For each File&quot; tool is to make the execution of complex tasks simple for the user. The ability to perform complex tasks with less typing and in a more human readable fashion are strong points of this tool. This tool also aims to enable the user to perform complex tasks without having to first write a separate shell script for it.</p>
						
						<p>This tool also improves the user's productivity by providing preset variables for use in their shell commands. Although it is a trivial matter to assemble these variables within a script, it becomes tedious to assemble them every time one wants to perform a quick task.</p>
						
						<p>I hope the following examples justify my claims.</p>
						
						<ul>
							<li>We wish to extract all <samp>*.tgz</samp> compressed tar files in the current working directory.
								<p>Here is the input for this example:<br/><code>$ ls -1<br/>bar.tgz<br/>foo.tgz</code></p>
								<p>Using this tool we can execute:<br/><code>$ ff *tgz -e 'tar -zxf "$f"'</code></p>
								<p>Using <samp>find -exec</samp> we can execute:<br/><code>$ find . -name '*tgz' -exec tar -zxf '{}' ';'</code></p>
							</li>
							<li>We wish to rename the file extension <samp>tgz</samp> to <samp>tar.gz</samp> and display the original file name upon success.
								<p>Here is the input for this example:<br/><code>$ ls -1 some_tgz/tgz_dir/<br/>bar.tgz<br/>b a z.tgz<br/>foo.tgz</code></p>
								<p>Using this tool we can execute:<br/><code>$ ff some_tgz/tgz_dir/*tgz -e 'mv "$f" "$d/${fn/%tgz/tar.gz}" &amp;&amp; echo $fn'</code></p>
								<p>Using <samp>find -exec</samp> we can execute:<br/><code>$ find some_tgz/tgz_dir/ -name '*tgz' -exec sh -c 'mv "{}" `dirname "{}"`/`basename "{}" | sed "s/tgz/tar.gz/"` &amp;&amp; `basename "{}"`' \;</code></p>
								<p>Notice that we invoked a shell with <samp>find -exec</samp> to perform this task. It may be possible to perform the task without the aid of an intermediate shell, however it would be difficult and is certainly not worth the effort in my opinion.</p>
							</li>
						</ul>
					</blockquote>
					
					<p>In conclusion, this tool simply allows for a different kind of approach to perform filesystem manipulation tasks while maintaining low usage of system resources. It is not meant to replace <samp>find -exec</samp> nor <samp>xargs</samp>.</p>
				</blockquote>
				</li>
				
				<li>Why is the <samp>read</samp> command in my script being ignored?
				<blockquote>
					<p>The BASH shell's <samp>read</samp> builtin command attempts to read user input from the standard input stream by default. However, the standard input stream may sometimes be in use by the '--pipe' option. To get around this, you can have the <samp>read</samp> builtin command read directly from the user's terminal by executing: <code>read < /dev/tty</code>.</p>
				</blockquote>
				</li>
				
				<li>&quot;For each File&quot; crash when a large number of targets are specified on the command-line.
				<blockquote>
					<p>The reason for this behavior is that the <samp>GNU BASH</samp> shell has buffer, of finite capacity, in which it stores command-line arguments. When a number of command-line arguments, exceeding the capacity of the shell's buffer, are presented to a command, the command may be terminated by the shell.</p>
					<p>One solution is to pipe the large list of targets to &quot;For each File&quot; whilst invoking it with the <samp>--pipe</samp> option:<br/><code>$ ls ... | ff --pipe</code></p>
				</blockquote>
				</li>
			</ol>
		</blockquote>
	</body>
</html>
