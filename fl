#!/bin/bash
#
# NAME
#	fl - for each line
#	<http://freshmeat.net/projects/ff/>
#
#
# SYNOPSIS
#	fl [OPTIONS]... FILE...
#
#
# OPTIONS
#	-e	Use the program specified in ${EDITOR} for entering scripting
#		commands. Depending on how your text editor handles I/O
#		redirection, this option may disable the ability to pipe output
#		to other programs.
#
#	-h	Display this help message.
#
#	-s FILE
#		Save scripting commands to the specified file.
#
#	-t FILE
#		Perform upon targets (non-directories or directories) listed in
#		the specified file, and ignore targets given on the command
#		line. Note that one target should be listed per line in the
#		specified file and either a relative or absolute path can be
#		used to specify a target.
#
#
# DESCRIPTION
#	Allows the user to execute a Bash script for each line in the specified
#	files. The script given by the user is interpreted directly by the Bash
#	shell.
#
#	If a directory is given as a target (non-directories) it is ignored.
#
# INSTRUCTIONS
#	(1) Invoking an existing script.
#
#		The existing script must be piped or redirected to this tool.
#
#		For example, to run a script named 'my_script' upon a file
#		'my_text', and save the output to the file 'my_output':
#
#			fl my_text < my_script > my_output
#
#			cat my_script | fl my_text | tee my_output
#
#		Notice that the '-e' option is not present. Depending on how
#		your text editor handles I/O redirection, omitting '-e' may
#		allow you to pipe or redirect input to this tool.
#
#		If your script reads from the standard input, then the above
#		commands will produce unwanted results. A solution is to
#		redirect a named file descriptor (other than 0) for input:
#		
#			read <&1 ; echo $REPLY
#
#	(2) Entering a script via standard input.
#
#		The user's commands will be read from standard input until an
#		EOT signal is detected. Multiple lines of input are allowed
#		(press RETURN to begin a new line).
#
#	(3) Entering a script via a text editor.
#
#		A global shell variable ${EDITOR} must be set to the path of the
#		user's desired text editor.
#
#		For example, if your text editor was located at '/foo/bar', you
#		would run the following to set ${EDITOR}.
#
#			declare -x EDITOR=/foo/bar
#
#		The text editor will then be launched for the user to enter
#		their script. Once the user has finished, they must save it in
#		their text editor before exiting.
#
#
# SCRIPTING FUNCTIONS
# 	The following functions allow greater control over the execution of
# 	commands in users' scripts. These are optional and need not be
# 	implemented. However, if any of these are implemented, the primary
# 	scripting commands must be located inside a function named 'main()'.
#
#	begin()		Invoked before any files are processed.
#
#	end()		Invoked after all files are processed.
#
#	begin_file()	Invoked before each file is processed.
#
#	end_file()	Invoked after each file is processed.
#
#	main()		Invoked once per line to process it.
#
#
# SCRIPTING VARIABLES
#	The following variables are available for use in users' scripts.
#
#	$fn	Basename of current file (non-directory).
#
#	$f	Path of current file (non-directory).
#
#	$d	Path of directory which contains current file (non-directory).
#
#	$w	Absolute path of user's current working directory.
#
#	$n	Total number of lines in current file (non-directory).
#
#	$i	Line number of current line.
#
#	$l	Contents of current line with leading and trailing whitespace 
#		removed.
#
#
# AUTHORS
# 	Suraj Kurapati <skurapat@ucsc.edu>
#
# LICENSE
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or   
#	(at your option) any later version.
#

## includes
	ff_libPath=${0%/*}/ff-lib
	
	if [ ! -r "$ff_libPath" ]
	then
		echo "Unable to source '$ff_libPath'."
		exit 1
	else
		source "$ff_libPath"
	fi

## globals

## functions

	# scan options and set flags
	# returns 2 if user asked to see help message
	ff_scanOptions()
	{
		# handle base options
		while getopts ${ff_baseOpts}${ff_cmdOpts} opt
		do
			ff_handleBaseOption $opt
			[ $? -gt 0 ] && return 1
		done
		
		return 0
	}
	
	ff_main()
	{
		# set scripting variable
		w=$PWD
		
		# user function
		begin
		
		# handle each target
		while read f
		do
			if [ -f "$f" ] # handle non-directories only
			then
			# set scripting variables
			
				f=${f%/}
				fn=${f##*/}
				
				# determine directory path
				if [ "$fn" == "$f" ]
				then
					d=.
					f=./$f
				else
					d=${f%/*}
				fi
				
				n=$( awk 'END {print NR}' "$f" )
				i=1
			
			# handle user's script
			
				# user function
				begin_file
				
				while read l
				do
					# user function
					main
					
					# increment line number
					let i=i+1
					
				done < "$f"
				
				# user function
				end_file
			fi
			
		done < "$ff_tmp_targetList"
		
		# user function
		end
	}
	
## main script logic

	ff_baseLogic "${@}"

