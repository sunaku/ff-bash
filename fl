#!/bin/bash
# For each Line (fl)
# This file is distributed under the same license as the "ff" package.

## global paths

	_ff_path=$0			# path to this program
	[ -L "$_ff_path" ] && _ff_path=$( find "$_ff_path" -printf "%l" )	# dereference if path is symlink
	
	_ff_name=${_ff_path#*/}		# basename of this program
	_ff_base=${_ff_path%/*}		# dirname of this program
	_ff_base_lib=${_ff_base}/lib	# libraries
	_ff_base_doc=${_ff_base}/doc	# documentation
	_ff_base_i18n=${_ff_base}/i18n	# i18n resources
	
## libraries

	source ${_ff_base_lib}/ff_common

## global variables

## functions

	# scan options and set flags
	# returns 2 if user asked to see help message
	_ff_scanOptions()
	{
		# handle base options
		while getopts ${_ff_baseOpts}${_ff_cmdOpts} opt
		do
			_ff_handleBaseOption $opt
			[ $? -gt 0 ] && return 1
		done
		
		return 0
	}
	
	_ff_main()
	{
		# scripting variables
		local w=$PWD d f fn n i l
		
		begin	# user function
		
		# handle each target
		for f in "${_ff_targetArray[@]}"
		do
			if [ -f "$f" ] # handle non-directories only
			then
			# set scripting variables
			
				f=${f%/}		# file's path
				fn=${f##*/}		# file's basename
				
				# determine directory path
				if [ "$fn" == "$f" ]
				then
					d=.
					f=./$f
				else
					d=${f%/*}
				fi
				
				n=$( wc -l "$f" )	# number of lines in file
				i=1			# number of current line
			
			# handle user's script
			
				begin_file		# user function
				
				while read -r l
				do
					main		# user function
					let i=i+1	# increment line number
					
				done < "$f"
				
				end_file		# user function
			fi
		done
		
		end	# user function
	}
	
## main script logic

	# dummy user functions
	begin() { :; }
	end() { :; }
	main() { :; }
	begin_file() { :; }
	end_file() { :; }

	# begin script
	_ff_baseLogic "${@}"

