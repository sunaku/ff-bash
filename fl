#!/bin/bash
#
# Source code for the "For each Line" tool.
#
###
#
# Copyright 2003, 2004 Suraj N. Kurapati.
#
###
#
# This file is part of "For each File".
# 
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###


## global paths

	# path to this program
	if [ -L "$0" ] # dereference if path is symlink
	then
		__ff_myPath=$( find "$0" -printf "%l" )
	else
		__ff_myPath=$0
	fi
	
	__ff_myName=${__ff_myPath##*/}		# basename of this program
	__ff_myHome=${__ff_myPath%/*}		# dirname of this program
	__ff_myResources_libs="${__ff_myHome}/libs"	# libraries
	__ff_myResources_docs="${__ff_myHome}/docs"	# documentation
	__ff_myResources_i18n="${__ff_myHome}/i18n"	# i18n resources
	__ff_myLang=${LANG:0:2}		# language code
	
## libraries

	source ${__ff_myResources_libs}/ff.lib

## global variables

	# temporary files

	# command line options

## functions

	# handles parsing of command-line options
	__lib_CmdOpts_handleOption()
	{
		# handle base options
		__lib_ff_handleOption "$1" "$2"
		return $?
	}
	
	# code for non-recursive mode
	__ff_main_linear_()
	{
		if [[ -f "$f" && -r "$f" ]] # check perms
		then
		
			# make implicit relative paths explicit
			[[ "${f:0:1}" != '/' && "${f:0:2}" != "./" ]] && f="./$f"
		
			# set scripting variables
			f=${f%/}
			fn=${f##*/}
			d=${f%/*}
			i=1
		
			# handle user's script
			begin_file	# user function
			
			while read -r l
			do
				main	# user function
				(( i += 1 ))	# increment line number
			done < "$f"
			
			end_file	# user function
		fi
	}
	
	__ff_main()
	{
		# scripting variables
		local w=$PWD d f fn i l __ff_oldIFS=$IFS
		
		# change IFS to only line breaks
		IFS='
'
		
		begin	# user function
		
		# handle command-line targets
		for f in "${__lib_ff_targetList[@]}"
		do
			__ff_main_linear_
		done
		
		# handle piped targets
		if [ ${__lib_ff_options_isOn_readPipe:-0} -eq 1 ]
		then
			while read -r f
			do
				__ff_main_linear_
			done
		fi
		
		end	# user function
		
		# restore IFS
		IFS=$__ff_oldIFS
	}
	
## main script logic

	# dummy user functions
	begin() { :; }
	end() { :; }
	main() { :; }
	begin_file() { :; }
	end_file() { :; }

	# begin script
	__lib_ff_targetList=( "${@}" )	# init arguments array
	__lib_ff_main

