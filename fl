#!/bin/bash
#
# NAME
#	fl - for each line
#	<http://freshmeat.net/projects/ff/>
#
#
# SYNOPSIS
#	fl [OPTIONS]... NON-DIRECTORY...
#
#
# OPTIONS
#	-e	Use the program specified in ${EDITOR} for entering scripting
#		commands. Depending on how your text editor handles I/O
#		redirection, this option may disable the ability to pipe output
#		to other programs.
#
#	-s FILE
#		Save given scripting commands to the specified file.
#		
#	-h	Display this help message.
#
#
# DESCRIPTION
#	Allows the user to execute a Bash script for each line in the specified
#	files. The script given by the user is interpreted directly by the BASH
#	shell.
#
#
# INSTRUCTIONS
#	(1) Invoking an existing script.
#
#		The existing script must be piped or redirected to this tool.
#
#		For example, to run a script named 'my_script' upon a file
#		'my_text', and save the output to the file 'my_output':
#
#			fl my_text < my_script > my_output
#
#			cat my_script | fl my_text | tee my_output
#
#		Notice that the '-e' option is not present. Depending on how
#		your text editor handles I/O redirection, omitting '-e' may
#		allow you to pipe or redirect input to this tool.
#
#		If your script reads from the standard input, then the above
#		commands will produce unwanted results. A solution is to
#		redirect a named file descriptor (other than 0) for input:
#		
#			read <&1 ; echo $REPLY
#
#	(2) Entering a script via standard input.
#
#		The user's commands will be read from standard input until an
#		EOT signal is detected. Multiple lines of input are allowed
#		(press RETURN to begin a new line).
#
#	(3) Entering a script via a text editor.
#
#		A global shell variable ${EDITOR} must be set to the path of the
#		user's desired text editor.
#
#		For example, if your text editor was located at '/foo/bar', you
#		would run the following to set ${EDITOR}.
#
#			declare -x EDITOR=/foo/bar
#
#		The text editor will then be launched for the user to enter
#		their script. Once the user has finished, they must save it in
#		their text editor before exiting.
#
#
# SCRIPTING FUNCTIONS
# 	The following functions allow greater control over the execution of
# 	commands in users' scripts. These are optional and need not be
# 	implemented. However, if any of these are implemented, the primary
# 	scripting commands must be located inside a function named 'main()'.
#
#	begin()		Invoked before any lines are processed.
#
#	end()		Invoked after all lines are processed.
#
#	main()		Invoked once per line to process it.
#
#
# SCRIPTING VARIABLES
#	The following variables are available for use in users' scripts.
#
#	$fn	Basename of current file (non-directory).
#
#	$f	Path of current file (non-directory).
#
#	$d	Path of directory which contains current file (non-directory).
#
#	$w	Absolute path of user's current working directory.
#
#	$n	Total number of lines in current file (non-directory).
#
#	$i	Index or line number of current line.
#
#	$l	Contents of current line with leading whitespace stripped off.
#
#
# AUTHORS
# 	Suraj Kurapati <skurapat@ucsc.edu>
#
# LICENSE
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or   
#	(at your option) any later version.
#

# includes
	source "${0%/*}/ff-lib"

# globals
	
	# option flags
	ff_cmdOpts="ehs:"
	ff_cmdOpts_opt_help=h
	ff_cmdOpts_opt_useEditor=e
	ff_cmdOpts_opt_saveInput=s
	
## functions

	# scan options and set flags
	# returns 2 if user asked to see help message
	ff_scanOptions()
	{
		while getopts $ff_cmdOpts opt
		do
			case $opt in
				$ff_cmdOpts_opt_useEditor)
					ff_cmdOpts_optEn_editor=1
				;;
				$ff_cmdOpts_opt_saveInput)
					ff_cmdOpts_optEn_saveInput=1
					ff_cmdOpts_optArg_saveInput=$OPTARG
				;;
				$ff_cmdOpts_opt_help)
					# display help message which happens to be the documentation header of this file
					sed -e '1d' -e '/^$/q' -e 's/^# *//' $0 | more
					return 2
				;;
				*)
					return 1
				;;
			esac
		done
	}
	
	ff_main()
	{
		# set scripting variable
		w=$PWD
		
		# loop through positional params
		for f
		do
			# set scripting variables
			f=${f%/}
			fn=${f##*/}
			if [ "$fn" == "$f" ] ; then d=$PWD ; else d=${f%/*} ; fi
			n=$( wc -l "$f" | awk '{print $1}' )
			i=1
			
			# call user func
			begin
			
			while read l
			do
				# execute user specified commands
				main
				
				# increment line number
				let i=i+1
				
			done < "$f"
			
			# call user func
			end
		done
	}
	
## main script logic

	# scan user options

		ff_scanOptions "${@}"

		# exit if help message was displayed
		# or if illegal options were given
		[ $? -gt 0 ] && ff_exit

	# get user script

		ff_getScript

		# exit if no script was given
		[ $? -gt 0 ] && ff_exit

	# handle options
	ff_saveScript

	# handle user's script
	
		# validate script
		ff_checkScriptMain

		# load script into RAM
		ff_evalScript
		
		# execute script
		ff_main "${@}"

	# clean up and exit
	ff_exit

