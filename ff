#!/bin/bash
#
# For each File enables one to execute an arbitrary set of GNU BASH shell commands upon an arbitrary set of files. It is useful for, but not limited to, performing repetitive file-system manipulation procedures such as mass file renaming.
#
###
#
# Copyright 2003, 2004, 2005 Suraj N. Kurapati.
#
# This file is part of "For each File".
#
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
###



# User interface configuration
	# Command-line options
		# Command-line options for the English language.
		function ffOptionBundle_en() {
			ffOption_showHelp='+(h|help)'	# this is an extended shell glob
			ffOption_showVersion='+(V|version)'
			ffOption_beVerbose='+(v|verbose)'
			ffOption_userTerminal='+(u|user-tty)'

			ffOption_evalExpr='+(e|expression)'
			ffOption_evalFile='+(f|file)'

			ffOption_pipeTargets='+(p|pipe)'
			ffOption_pipeDelimiter='+(pipe-delim)'

			ffOption_beRecursive='+(r|recursive)'
			ffOption_handleHidden='+(a|all)'
			ffOption_ignoreLinks='+(L|ignore-links)'
			ffOption_targetMask='+(m|mask)'
		}



	# Text messages
		# Text messages for the English language.
		function ffTextBundle_en() {
			ffText_errorInvalidOption='Error: "%s" is not a valid option.'
			ffText_errorCannotReadFile='Error: I cannot read the "%s" file.'
			ffText_errorNeedMoreArguments='Error: You must specify more arguments for the "%s" option.'
		}



# Internal variables
	ffReleaseVersion=2.0
	ffReleaseDate=yyyy-mm-dd

	ffLanguageCode_default=en
	ffLanguageCode=$( expr substr ${LANG:-$ffLanguageCode_default} 1 2 )

	ffUserTerminal_default=/dev/tty

	# indices within a ffOption_* array
	ffOptionIndex_isOn=1
	ffOptionIndex_args=2


	ffOptionPrefix_short=-
	ffOptionPrefix_long=--

	ffExitCode_success=0
	ffExitCode_userError=1
	ffExitCode_systemError=2
	ffExitCode_internalError=3



# Internal logic
	# Says the given message to the user via 'printf'
	function ffLogic_say() {
		echo "ff: $( printf "$@" )"
	}



	# Handles command-line options
	# @param	The command-line option to handle
	# @param	All command-line arguments that follow the given option
	# @return	The number of command-line arguments consumed by the given option
	function ffLogic_handleOption() {
		local option=$1
		shift

		case "$option" in
			$ffOption_showHelp)
				return 0
			;;

			$ffOption_showVersion)
				echo $ffReleaseVersion $ffReleaseDate
				return 0
			;;

			$ffOption_beVerbose)
				ffOption_beVerbose[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_userTerminal)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_userTerminal[$ffOptionIndex_isOn]=true
				ffOption_userTerminal[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_evalExpr)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_evalExpr[$ffOptionIndex_isOn]=true
				ffOption_evalExpr[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_evalFile)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_evalFile[$ffOptionIndex_isOn]=true
				ffOption_evalFile[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_pipeTargets)
				ffOption_pipeTargets[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_pipeDelimiter)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_pipeDelimiter[$ffOptionIndex_isOn]=true
				ffOption_pipeDelimiter[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_beRecursive)
				ffOption_beRecursive[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_handleHidden)
				ffOption_handleHidden[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_ignoreLinks)
				ffOption_ignoreLinks[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_targetMask)
				ffOption_targetMask[$ffOptionIndex_isOn]=true
				return 0
			;;

			*)
				ffLogic_say "$ffText_errorInvalidOption" "$option"
				exit $ffExitCode_userError
			;;
		esac
	}



	# Parses command-line arguments
	# @param	Name of an array which will hold the parsed arguments
	function ffLogic_parseArgs() {
		local arg arguments arguments_callBack=$1
		shift

		while (( $# > 0 )); do
			arg=$1
			shift

			case $arg in
				${ffOptionPrefix_long}*)
					ffLogic_handleOption ${arg:${#ffOptionPrefix_long}} "$@"
					shift $?
				;;

				${ffOptionPrefix_short}*)
					local i options=${arg:${#ffOptionPrefix_short}}

					# handle mulitple short options that have been grouped together into a single word
					for (( i = 0; i < ${#options}; i++ )); do
						ffLogic_handleOption ${options:0:1} "$@"
						shift $?
					done
				;;

				*)
					arguments[${#arguments[@]}]=$arg
				;;
			esac
		done


		# propogate parsed arguments back to caller
		eval "$arguments_callBack=( \${arguments[@]} )"
	}



	# Loads the user's script.
	ffLogic_loadScript()
	{
		local expression=":;"

		if ${ffOption_evalExpr[$ffOptionIndex_isOn]:-false}; then
			# read command-line argument
			expression=${ffOption_evalExpr[$ffOptionIndex_args]}

		elif ${ffOption_evalFile[$ffOptionIndex_isOn]:-false}; then
			# read script file
			local scriptFile=${ffOption_evalFile[$ffOptionIndex_args]}

			if [ -f $scriptFile -a -r $scriptFile ]; then
				expression=$( < $scriptFile )
			else
				ffLogic_say "$ffText_errorCannotReadFile" "\"$scriptFile\""
				exit 2
			fi

		else
			# read user's terminal
			while IFS= read -er < ${ffOption_evalFile[$ffOptionIndex_args]:-$ffUserTerminal_default}; do
				expression="$expression
$REPLY"
			done
		fi


		# check input for control functions
		if [ -n "${expression/*during*( |	)\(*( |	)\)*/}" -a -n "${expression/*function+( |	)during*/}" ]; then
			expression="
during(){
$expression
:;}"
		fi


		# load script into RAM
		eval "$expression"
	}



	# Recursively executes 'during()' on the given directory
	ffLogic_recursiveMode()
	{
		local o n p d=$1
		shift

		# handle all directories
		for p in "$d"/*; do
			if [ -L "$p" ] && ! ${ffOption_ignoreLinks[$ffOptionIndex_isOn]:-false} || [ -d "$p" ]; then
				ffLogic_recursiveMode "$p"
			fi
		done

		# handle all files
		for o in "$d"/${ffOption_targetMask[$ffOptionIndex_args]:-*}
		do
			# update preset variables
			p=$o	# redundant slashes have already been removed
			n=${p##*/}	# keep everything after the last slash

			during
		done
	}



	# Linearly executes 'during()' on the given arguments
	ffLogic_linearMode() {
		for o; do
			p=$o

			# handle special cases
			case $p in
				/)
					n=/
					d=/
					return
				;;
				.)
					n=.
					d=.
					return
				;;
				..)
					n=..
					d=.
					return
				;;

				/*|./*|../*)
					# path is already explicit
				;;

				*)
					# convert implicit relative paths into explicit relative paths
					p="./$p"
				;;
			esac


			# update preset variables
				# remove redundant slashes
				p=${p//+(\/)//}

				# remove trailing slash
				p=${p%/}

				# keep everything after the last slash
				n=${p##*/}

				# keep everything before the last slash
				d=${d%/*}

				# special case: $d is empty when it should be /
				if [ -z "$d" ]; then
					d=/
				fi


			during
		done
	}



	# Performs upon arguments given on the pipe
	# @param	Function that will handle arguments on the pipe
	ffLogic_pipeWrapper() {
		if ${ffOption_pipeTargets[$ffOptionIndex_isOn]:-false}; then
			local oldIfs=$IFS


			# apply user-defined pipe delimiter
			if ${ffOption_pipeDelimiter[$ffOptionIndex_isOn]:-false}; then
				IFS=${ffOption_pipeDelimiter[$ffOptionIndex_args]}
			fi


			# execute arguments from pipe
			while read -r; do
				$1 "$REPLY"
			done


			# restore pipe delimiter
			IFS=$oldIfs
		fi
	}



	# Primary entry point into this file's logic
	ff() {
		# run the following code in a sub-shell because it uses the 'exit' command at some point. Without this sub-shell, the 'exit' command will close the user's terminal!
		(
			# dummy functions that are executed when user hasn't overridden them
			function before() { :; }
			function during() { :; }
			function after() { :; }
			function end() { :; }


			# ensure proper clean up during exit
			trap "exit $ffExitCode_systemError" INT KILL TERM HUP
			trap end EXIT


			# set options for current sub-shell
			shopt -s extglob


			# load localized bundles for current language
			ffOptionBundle_$ffLanguageCode
			ffTextBundle_$ffLanguageCode


			# parse command-line arguments
			local -a parsedArgs
			ffLogic_parseArgs parsedArgs "$@"


			# handle special command-line options
			if ${ffOption_beVerbose[$ffOptionIndex_isOn]:-false}; then
				set -x
			fi

			if ${ffOption_handleHidden[$ffOptionIndex_isOn]:-false}; then
				shopt -s dotglob
			fi


			# execute user's script
			ffLogic_loadScript

			before "${parsedArgs[@]}"

			if ${ffOption_beRecursive[$ffOptionIndex_isOn]:-false}; then

				local arg
				for arg in "${parsedArgs[@]}"; do
					ffLogic_recursiveMode "$arg"
				done

				ffLogic_pipeWrapper ffLogic_recursiveMode
			else
				ffLogic_linearMode "${parsedArgs[@]}"
				ffLogic_pipeWrapper ffLogic_linearMode
			fi

			after "${parsedArgs[@]}"

			# note: end() is called by the EXIT trap
		)
	}

