#!/bin/bash
#
# For each File enables one to execute an arbitrary set of GNU BASH shell
# commands upon an arbitrary set of files. It can be used for performing
# repetitive file-system manipulation procedures, such as mass file renaming
# and gathering file-system statistics.
#
###
#
# Copyright 2003, 2004, 2005 Suraj N. Kurapati.
#
# This file is part of "For each File".
#
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
###



# User interface configuration
	# Command-line options
		# Command-line options for the English language.
		function ffOptionBundle_en() {
			# @note the following values are extended shell globs
			ffOption_showHelp='+(h|help)'
			ffOption_showVersion='+(V|version)'
			ffOption_beVerbose='+(v|verbose)'
			ffOption_pipeTargets='+(p|pipe)'
			ffOption_extDelim='ext-delim'


			ffOption_evalExpr='+(e|expression)'
			ffOption_evalFile='+(f|file)'


			ffOption_beRecursive='+(r|recursive)'
			ffOption_handleHidden='+(a|all)'
			ffOption_ignoreLinks='+(L|ignore-links)'
			ffOption_targetMask='+(m|mask)'
		}



	# Text messages
		# Text messages for the English language.
		function ffTextBundle_en() {
			ffText_errorInvalidOption='Error: You specified an invalid option: %s'
			ffText_errorCannotReadFile='Error: I could not read the following file: %s'
			ffText_errorNeedMoreArguments='Error: You must specify more arguments for option: %s'
			ffText_errorBadUserScript='Error: I could not process your script: %s'
		}



# Internal variables
	declare -r ffReleaseVersion=2.0
	declare -r ffReleaseDate=yyyy-mm-dd

	declare -r ffNewLine=$'\n'
	declare -r ffExtDelim_default=.
	declare -r ffUserTerminal_default=/dev/tty

	declare -r ffLanguageCode_default=en
	ffLanguageCode=$( expr substr ${LANG:-$ffLanguageCode_default} 1 2 )


	# indices within a ffOption_* array
	declare -r ffOptionIndex_isOn=1
	declare -r ffOptionIndex_arg=2


	# prefixes that appear before command-line options and distinguish them from regular command-line arguments
	declare -r ffOptionPrefix_short=-
	declare -r ffOptionPrefix_long=--


	declare -r ffExitCode_success=0
	declare -r ffExitCode_userError=1
	declare -r ffExitCode_systemError=2
	declare -r ffExitCode_internalError=3



# Internal logic
	# Says the given message to the user via 'printf'
	# @param	.	The format string used by printf
	# @param	...	The arguments for the format string
	function ffLogic_say() {
		echo "ff: $( printf "$@" )"
	}



	# Enables the given option and associates the given arguments with it
	# @param	.	Number of arguments available to the given option
	# @param	.	Option flag (how the user specifies the option)
	# @param	.	Variable name associated with option (callback)
	# @param	.	Argument to associate with option
	function ffLogic_enableOption() {
		if [ $1 -lt 1 ]; then
			ffLogic_say "$ffText_errorNeedMoreArguments" "$2"
			exit $ffExitCode_userError
		fi

		eval "$3[$ffOptionIndex_isOn]=true"
		eval "$3[$ffOptionIndex_arg]=\$4"
	}



	# Handles command-line options
	# @param	.	The command-line option to handle
	# @param	.	All command-line arguments that follow the given option
	# @return	The number of command-line arguments consumed by the given option
	function ffLogic_handleOption() {
		local option=$1
		shift

		case "$option" in
			$ffOption_showHelp)
				# show a list of available options
				for option in ${!ffOption_*}; do
					echo "${!option}"
				done

				exit $ffExitCode_success
			;;

			$ffOption_showVersion)
				echo $ffReleaseVersion $ffReleaseDate
				exit $ffExitCode_success
			;;

			$ffOption_beVerbose)
				ffOption_beVerbose[$ffOptionIndex_isOn]=true
				set -x
				return 0
			;;

			$ffOption_pipeTargets)
				ffOption_pipeTargets[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_extDelim)
				ffLogic_enableOption $# "$option" ffOption_extDelim "$1"
				return 1
			;;

			$ffOption_evalExpr)
				ffLogic_enableOption $# "$option" ffOption_evalExpr "$1"
				return 1
			;;

			$ffOption_evalFile)
				ffLogic_enableOption $# "$option" ffOption_evalFile "$1"
				return 1
			;;

			$ffOption_beRecursive)
				ffOption_beRecursive[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_handleHidden)
				ffOption_handleHidden[$ffOptionIndex_isOn]=true
				shopt -s dotglob
				return 0
			;;

			$ffOption_ignoreLinks)
				ffOption_ignoreLinks[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_targetMask)
				ffLogic_enableOption $# "$option" ffOption_targetMask "$1"
				return 1
			;;

			*)
				ffLogic_say "$ffText_errorInvalidOption" "$option"
				exit $ffExitCode_userError
			;;
		esac
	}



	# Parses command-line arguments
	# @param	.	Name of an array which will hold the parsed arguments
	function ffLogic_parseArgs() {
		local arg arguments arguments_callBack=$1
		shift

		while [ $# -gt 0 ]; do
			arg=$1
			shift

			case "$arg" in
				$ffOptionPrefix_long)
					# stop parsing and consider the remaining command-line arguments as arguments
					arguments=( "${arguments[@]}" "$@" )
					break
				;;

				${ffOptionPrefix_long}*)
					ffLogic_handleOption ${arg:${#ffOptionPrefix_long}} "$@"
					shift $?
				;;

				${ffOptionPrefix_short}*)
					local i options=${arg:${#ffOptionPrefix_short}}

					# handle mulitple short options that have been grouped together into a single word
					for (( i = 0; i < ${#options}; i++ )); do
						ffLogic_handleOption ${options:$i:1} "$@"
						shift $?
					done
				;;

				*)
					arguments[${#arguments[@]}]=$arg
				;;
			esac
		done


		# propogate parsed arguments back to caller
		eval "$arguments_callBack=( \${arguments[@]} )"
	}



	# Loads the user's script from command-line argument or user's terminal.
	function ffLogic_loadScript() {
		local expression=:

		if ${ffOption_evalExpr[$ffOptionIndex_isOn]:-false}; then
			# read command-line argument
			expression=${ffOption_evalExpr[$ffOptionIndex_arg]}

		elif ${ffOption_evalFile[$ffOptionIndex_isOn]:-false}; then
			# read script file
			local scriptFile=${ffOption_evalFile[$ffOptionIndex_arg]}

			if [ -f $scriptFile -a -r $scriptFile ]; then
				expression=$( < $scriptFile )
			else
				ffLogic_say "$ffText_errorCannotReadFile" "$scriptFile"
				exit 2
			fi

		else
			# read user's terminal
			while read -er < $ffUserTerminal_default; do
				expression="$expression${ffNewLine}$REPLY"
			done
		fi


		# ensure that user's script has the during() function
		if ! grep 'during[:space:]*([:space:]*)' <<< "$expression" >& /dev/null; then
			expression="during(){ $expression; }"
		fi


		# load the user's script
		eval "$expression"

		if ! declare -F during >& /dev/null; then
			ffLogic_say "$ffText_errorBadUserScript" "$expression"
			exit $ffExitCode_internalError
		fi
	}



	# Recursively executes 'during()' on the given directory
	# @param	...	directories upon which to perform
	function ffLogic_recursiveMode() {
		while [ $# -gt 0 ]; do
			# handle files which match the target mask
			ffLogic_linearMode "$1"/${ffOption_targetMask[$ffOptionIndex_arg]:-*}


			# handle directories recursively
			for o in "$1"/*; do
				if [ -d "$o" ]; then
					# skip links if user has specified so
					if [ -L "$o" ] && ${ffOption_ignoreLinks[$ffOptionIndex_isOn]:-false}; then
						continue
					fi


					ffLogic_recursiveMode "$o"
				fi
			done


			shift
		done
	}



	# Linearly executes 'during()' on the given argument
	# @param	...	the files upon which to perform
	function ffLogic_linearMode() {
		for o; do
			# update preset variables
				# handle special cases
				case "$o" in
					/)
						p=/
						d=/
						n=/
						b=/
					;;

					.)
						p=./.
						d=.
						n=.
						b=.
					;;

					..)
						p=./..
						d=.
						n=..
						b=..
					;;

					*)
						p=${o//+(\/)/\/}
						p=${p%/}

						d=${p%/*}
						d=${d:-/}	# special case: $d is empty when it should be /

						n=${p##*/}
						b=${n%${ffOption_extDelim[ffOptionIndex_arg]:-$ffExtDelim_default}*}
					;;
				esac


				# parse the file extension
				if expr index "$n" "${ffOption_extDelim[ffOptionIndex_arg]:-$ffExtDelim_default}" >& /dev/null; then
					e=${n##*${ffOption_extDelim[ffOptionIndex_arg]:-$ffExtDelim_default}}
				else
					e=
				fi


			during
		done
	}



	# Primary entry point into this file's logic
	# @param	...	Command-line arguments
	function ff() {
		# run the following code in a sub-shell because it uses the 'exit' command at some point. Without this sub-shell, the 'exit' command will close the user's terminal!
		(
			# dummy functions that are executed when user hasn't overridden them
			function before() { :; }
			function during() { :; }
			function after() { :; }
			function end() { :; }


			# ensure proper clean up during exit
			trap "exit $ffExitCode_systemError" INT KILL TERM HUP
			trap end EXIT


			# set options for current sub-shell
			shopt -s extglob nullglob


			# load localized string bundles for current language
			ffTextBundle_$ffLanguageCode
			ffOptionBundle_$ffLanguageCode


			# parse command-line arguments
			local -a parsedArgs
			ffLogic_parseArgs parsedArgs "$@"


			# determine which mode (linear or recursive) to execute in
			local mode=ffLogic_linearMode

			if ${ffOption_beRecursive[$ffOptionIndex_isOn]:-false}; then
				mode=ffLogic_recursiveMode
			fi


			# load and execute user's script
			ffLogic_loadScript

			before "${parsedArgs[@]}"

				local o p d n b e


				# execute the user's script on command-line arguments
				$mode "${parsedArgs[@]}"


				# execute the user's script on piped arguments
				if ${ffOption_pipeTargets[$ffOptionIndex_isOn]:-false}; then
					while read -r o; do
						$mode "$o"
					done
				fi

			after "${parsedArgs[@]}"

			# @note end() is automatically called by the EXIT trap
		)
	}

