#!/bin/bash
#
# Source code for the "For each File" tool.
#
###
#
# Copyright 2003-2004 Suraj N. Kurapati.
#
###
#
# This file is part of "For each File".
# 
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###


## global paths

	__ff_myPath=$0			# path to this program
	[ -L "$__ff_myPath" ] && __ff_myPath=$( find "$__ff_myPath" -printf "%l" )	# dereference if path is symlink
	
	__ff_myName=${__ff_myPath##*/}		# basename of this program
	__ff_myHome=${__ff_myPath%/*}		# dirname of this program
	__ff_myResources_libs=${__ff_myHome}/libs	# libraries
	__ff_myResources_docs=${__ff_myHome}/docs	# documentation
	__ff_myResources_i18n=${__ff_myHome}/i18n	# i18n resources
	__ff_myLang=${LANG:0:2}		# language code
	
## libraries

	source ${__ff_myResources_libs}/ff.lib

## global variables

	# temporary files

	# command line options
	
		__ff_myOptions_shortFlag_handleHidden=a
		__ff_myOptions_longFlag_handleHidden=all
		
		__ff_myOptions_shortFlag_followLinks=d
		__ff_myOptions_longFlag_followLinks=dereference
		
		__ff_myOptions_shortFlag_recursive=r
		__ff_myOptions_longFlag_recursive=recursive

## functions

	# handles parsing of command-line options
	__lib_CmdOpts_handleOption()
	{
		case "$1" in
			$__ff_myOptions_shortFlag_handleHidden | $__ff_myOptions_longFlag_handleHidden)
				__ff_myOptions_isOn_handleHidden=1
				return 1
			;;
			$__ff_myOptions_shortFlag_followLinks | $__ff_myOptions_longFlag_followLinks)
				__ff_myOptions_isOn_followLinks=1
				return 1
			;;
			$__ff_myOptions_shortFlag_recursive | $__ff_myOptions_longFlag_recursive)
				__ff_myOptions_isOn_recursive=1
				return 1
			;;
			*) # handle base options
				__lib_ff_handleOption "$1" "$2"
				return $?
			;;
		esac
	}

	__ff_main()
	{
		# scripting variables
		local w=$PWD d f fn
		
		begin	# user function

		# check method of operation: recursive or non-recursive
		if [ ${__ff_myOptions_isOn_recursive:-0} -eq 1 ] # recursive operation
		then
		
			local __ff_baseDir __ff_findOpts=-depth

			# handle options for recursive behavior
				[ ${__ff_myOptions_isOn_followLinks:-0} -eq 1 ] && __ff_findOpts[${#__ff_findOpts[@]}]=-follow
				
				if [ ${__ff_myOptions_isOn_handleHidden:-0} -eq 0 ]
				then
					__ff_findOpts[${#__ff_findOpts[@]}]=-name
					__ff_findOpts[${#__ff_findOpts[@]}]='*'
				fi
			
			# handle each target
			for __ff_baseDir in "${__lib_ff_targetList[@]}"
			do
				if [ -d "$__ff_baseDir" ] # handle directories only
				then
					find "$__ff_baseDir" "${__ff_findOpts[@]}" |
					while read f
					do
						# set scripting variables
						fn=${f##*/}
						d=${f%/*}
						
						main	# user function
					done
				fi
			done

		else # non-recursive operation

			# handle each target
			for f in "${__lib_ff_targetList[@]}"
			do
				# make implicit relative paths explicit
				[[ "${f:0:1}" != '/' && "${f:0:2}" != "./" ]] && f="./$f"
				
				# set scripting variables
				f=${f%/}
				fn=${f##*/}
				d=${f%/*}
				
				main	# user function
			
			done
		fi

		end	# user function
	}

## main script logic

	# dummy user functions
	begin() { :; }
	end() { :; }
	main() { :; }
	
	# begin script
	__lib_ff_targetList=( "${@}" )	# init arguments array
	__lib_ff_main

