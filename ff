#!/bin/bash
#
# NAME
#	ff - for each file
#	<http://freshmeat.net/projects/ff/>
#
#
# SYNOPSIS
#	ff [OPTIONS]... FILE...
#
#
# OPTIONS
#	-a	Handle files prefixed with a period (hidden files). Note that
#		this applies in recursive mode only.
#
#	-e	Use the program specified in ${EDITOR} for entering scripting
#		commands. Depending on how your text editor handles I/O
#		redirection, this option may disable the ability to pipe output
#		to other programs.
#
#	-h	Display this help message.
#
#	-l	Follow symbolic links to directories. Note that this applies in
#		recursive mode only.
#
#	-r	Handle subdirectories recursively. Note that directories are
#		handled before non-directories.
#
#	-s FILE
#		Save scripting commands to the specified file.
#
#	-t FILE
#		Perform upon targets (non-directories or directories) listed in
#		the specified file, and ignore targets given on the command
#		line. Note that one target should be listed per line in the
#		specified file and either a relative or absolute path can be
#		used to specify a target.
#
#
# DESCRIPTION
#	Allows the user to execute a Bash script recursively upon many files and
#	directories. It is ideal for performing a repetitive procedure such as
#	mass file renaming. The script given by the user is interpreted directly
#	by the Bash shell.
#
# INSTRUCTIONS
#	(1) Invoking an existing script.
#
#		The existing script must be piped or redirected to this tool.
#
#		For example, to run a script named 'my_script' upon a directory
#		'my_dir', and save the output to the file 'my_output':
#
#			ff -r my_dir < my_script > my_output
#
#			cat my_script | ff -r my_dir | tee my_output
#
#		Notice that the '-e' option is not present. Depending on how
#		your text editor handles I/O redirection, omitting '-e' may
#		allow you to pipe or redirect input to this tool.
#
#		If your script reads from the standard input, then the above
#		commands will produce unwanted results. A solution is to
#		redirect a named file descriptor (other than 0) for input:
#
#			read <&1 ; echo $REPLY
#
#	(2) Entering a script via standard input.
#
#		The user's commands will be read from standard input until an
#		EOT signal is detected. Multiple lines of input are allowed
#		(press RETURN to begin a new line).
#
#	(3) Entering a script via a text editor.
#
#		A global shell variable ${EDITOR} must be set to the path of the
#		user's desired text editor.
#
#		For example, if your text editor was located at '/foo/bar', you
#		would run the following to set ${EDITOR}.
#
#			declare -x EDITOR=/foo/bar
#
#		The text editor will then be launched for the user to enter
#		their script. Once the user has finished, they must save it in
#		their text editor before exiting.
#
#
# SCRIPTING FUNCTIONS
# 	The following functions allow greater control over the execution of
# 	commands in users' scripts. These are optional and need not be
# 	implemented. However, if any of these are implemented, the primary
# 	scripting commands must be located inside a function named 'main()'.
#
#	begin()		Invoked before any files are processed.
#
#	end()		Invoked after all files are processed.
#
#	main()		Invoked once per file to process it.
#
#
# SCRIPTING VARIABLES
#	The following variables are available for use in users' scripts.
#
#	$fn	Basename of current file (directory or non-directory).
#
#	$f	Path of current file (directory or non-directory).
#
#	$d	Path of directory which contains current file (directory or
#		non-directory).
#
#	$w	Absolute path of user's current working directory.
#
#
# AUTHORS
# 	Suraj Kurapati <skurapat@ucsc.edu>
#
#
# LICENSE
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#

## includes
	ff_libPath=${0%/*}/ff-lib
	
	if [ ! -r "$ff_libPath" ]
	then
		echo "Unable to source '$ff_libPath'."
		exit 1
	else
		source "$ff_libPath"
	fi

## globals

	# temporary files
	ff_tmp_dirList=${ff_tmpMask}.dirList

	# command line options
	ff_cmdOpts=alr
	ff_cmdOpts_optFlg_handleHidden=a
	ff_cmdOpts_optFlg_followLinks=l
	ff_cmdOpts_optFlg_recursive=r

## functions

	# scan options and set flags
	# @return	1	illegeal options
	ff_scanOptions()
	{
		while getopts ${ff_baseOpts}${ff_cmdOpts} opt
		do
			case $opt in
				$ff_cmdOpts_optFlg_handleHidden)
					ff_cmdOpts_optEn_handleHidden=1
				;;
				$ff_cmdOpts_optFlg_followLinks)
					ff_cmdOpts_optEn_followLinks=1
				;;
				$ff_cmdOpts_optFlg_recursive)
					ff_cmdOpts_optEn_recursive=1
				;;
				*) # handle base options
					ff_handleBaseOption $opt
					[ $? -gt 0 ] && return 1
				;;
			esac
		done
		
		return 0
	}

	ff_main()
	{
		# set scripting variables
		w=$PWD

		# user function
		begin

		# check method of operation: recursive or non-recursive
		if [ ${ff_cmdOpts_optEn_recursive:-0} -eq 1 ] # recursive operation
		then
			local basedir

			# handle each target
			while read basedir
			do
				if [ -d "$basedir" ] # handle directories only
				then
					# handle all subdirectories, starting with the deepest sub-directories first
					ls -R${ff_cmdOpts_optEn_followLinks:+L}${ff_cmdOpts_optEn_handleHidden:+A} "$basedir" | sed -n 's/:$//p' | sort -r | \
					while read d
					do
						# set scripting variables
						d=${d%/}
						
						# for all files in subdir
						for f in "$d"/* $( [ ! -z "$ff_cmdOpts_optEn_handleHidden" ] && echo "$d/.*" )
						do
							# set scripting variables
							fn=${f##*/}

							# user function
							main
						done
					done
				fi
				
			done < "$ff_tmp_targetList"

		else # non-recursive operation

			# handle each target
			while read f
			do
				# set scripting variables
				
					f=${f%/}
					fn=${f##*/}
					
					# determine directory path
					if [ "$fn" != "$f" ]
					then
						d=${f%/*}
					else
						d=.
						f=./$f
					fi
				
				# handle user's script

					# user function
					main
				
			done < "$ff_tmp_targetList"
		fi

		# user function
		end
	}

## main script logic

	ff_baseLogic "${@}"

