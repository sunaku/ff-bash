#!/bin/bash
#
# For each File enables one to execute an arbitrary set of GNU BASH shell
# commands upon an arbitrary set of files. It can be used for performing
# repetitive file-system manipulation procedures, such as mass file renaming
# and gathering file-system statistics.
#
###
#
# Copyright 2003, 2004, 2005 Suraj N. Kurapati.
#
# This file is part of "For each File".
#
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
###



# User interface configuration
	# Command-line options
		# Command-line options for the English language.
		function ffOptionBundle_en() {
			# @note the following values are extended shell globs
			ffOption_showHelp='+(h|help)'
			ffOption_showVersion='+(V|version)'
			ffOption_beVerbose='+(v|verbose)'
			ffOption_pipeTargets='+(p|pipe)'


			ffOption_evalExpr='+(e|expression)'
			ffOption_evalFile='+(f|file)'


			ffOption_beRecursive='+(r|recursive)'
			ffOption_handleHidden='+(a|all)'
			ffOption_ignoreLinks='+(L|ignore-links)'
			ffOption_targetMask='+(m|mask)'
		}



	# Text messages
		# Text messages for the English language.
		function ffTextBundle_en() {
			ffText_errorInvalidOption='Error: You specified an invalid option: %s'
			ffText_errorCannotReadFile='Error: I could not read the following file: %s'
			ffText_errorNeedMoreArguments='Error: You must specify more arguments for option: %s'
			ffText_errorBadUserScript='Error: I could not process your script: %s'
		}



# Internal variables
	declare -r ffReleaseVersion=2.0
	declare -r ffReleaseDate=yyyy-mm-dd

	declare -r ffNewLine=$'\n'
	declare -r ffUserTerminal_default=/dev/tty
	declare -r ffLanguageCode_default=en
	ffLanguageCode=$( expr substr ${LANG:-$ffLanguageCode_default} 1 2 )


	# indices within a ffOption_* array
	declare -r ffOptionIndex_isOn=1
	declare -r ffOptionIndex_args=2


	# prefixes that appear before command-line options and distinguish them from regular command-line arguments
	declare -r ffOptionPrefix_short=-
	declare -r ffOptionPrefix_long=--


	declare -r ffExitCode_success=0
	declare -r ffExitCode_userError=1
	declare -r ffExitCode_systemError=2
	declare -r ffExitCode_internalError=3



# Internal logic
	# Says the given message to the user via 'printf'
	function ffLogic_say() {
		echo "ff: $( printf "$@" )"
	}



	# Handles command-line options
	# @param	The command-line option to handle
	# @param	All command-line arguments that follow the given option
	# @return	The number of command-line arguments consumed by the given option
	function ffLogic_handleOption() {
		local option=$1
		shift

		case "$option" in
			$ffOption_showHelp)
				# show a list of available options
				for option in ${!ffOption_*}; do
					echo "${!option}"
				done

				exit $ffExitCode_success
			;;

			$ffOption_showVersion)
				echo $ffReleaseVersion $ffReleaseDate
				exit $ffExitCode_success
			;;

			$ffOption_beVerbose)
				ffOption_beVerbose[$ffOptionIndex_isOn]=true
				set -x
				return 0
			;;

			$ffOption_pipeTargets)
				ffOption_pipeTargets[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_evalExpr)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_evalExpr[$ffOptionIndex_isOn]=true
				ffOption_evalExpr[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_evalFile)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_evalFile[$ffOptionIndex_isOn]=true
				ffOption_evalFile[$ffOptionIndex_args]=$1
				return 1
			;;

			$ffOption_beRecursive)
				ffOption_beRecursive[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_handleHidden)
				ffOption_handleHidden[$ffOptionIndex_isOn]=true
				shopt -s dotglob
				return 0
			;;

			$ffOption_ignoreLinks)
				ffOption_ignoreLinks[$ffOptionIndex_isOn]=true
				return 0
			;;

			$ffOption_targetMask)
				(( $# < 1 )) &&
				ffLogic_say "$ffText_errorNeedMoreArguments" "$option" &&
				exit $ffExitCode_userError

				ffOption_targetMask[$ffOptionIndex_isOn]=true
				ffOption_targetMask[$ffOptionIndex_args]=$1
				return 1
			;;

			*)
				ffLogic_say "$ffText_errorInvalidOption" "$option"
				exit $ffExitCode_userError
			;;
		esac
	}



	# Parses command-line arguments
	# @param	Name of an array which will hold the parsed arguments
	function ffLogic_parseArgs() {
		local arg arguments arguments_callBack=$1
		shift

		while (( $# > 0 )); do
			arg=$1
			shift

			case "$arg" in
				$ffOptionPrefix_long)
					# stop parsing and consider the remaining command-line arguments as arguments
					arguments=( "${arguments[@]}" "$@" )
					break
				;;

				${ffOptionPrefix_long}*)
					ffLogic_handleOption ${arg:${#ffOptionPrefix_long}} "$@"
					shift $?
				;;

				${ffOptionPrefix_short}*)
					local i options=${arg:${#ffOptionPrefix_short}}

					# handle mulitple short options that have been grouped together into a single word
					for (( i = 0; i < ${#options}; i++ )); do
						ffLogic_handleOption ${options:$i:1} "$@"
						shift $?
					done
				;;

				*)
					arguments[${#arguments[@]}]=$arg
				;;
			esac
		done


		# propogate parsed arguments back to caller
		eval "$arguments_callBack=( \${arguments[@]} )"
	}



	# Loads the user's script from command-line argument or user's terminal.
	ffLogic_loadScript()
	{
		local expression=:

		if ${ffOption_evalExpr[$ffOptionIndex_isOn]:-false}; then
			# read command-line argument
			expression=${ffOption_evalExpr[$ffOptionIndex_args]}

		elif ${ffOption_evalFile[$ffOptionIndex_isOn]:-false}; then
			# read script file
			local scriptFile=${ffOption_evalFile[$ffOptionIndex_args]}

			if [ -f $scriptFile -a -r $scriptFile ]; then
				expression=$( < $scriptFile )
			else
				ffLogic_say "$ffText_errorCannotReadFile" "$scriptFile"
				exit 2
			fi

		else
			# read user's terminal
			while read -er < $ffUserTerminal_default; do
				expression="$expression${ffNewLine}$REPLY"
			done
		fi


		# ensure that user's script has during() function
		if ! grep 'during[:space:]*([:space:]*)' <<< "$expression" >& /dev/null; then
			expression="during(){ $expression; }"
		fi


		# load the user's script
		eval "$expression"

		! declare -F during >& /dev/null &&
		ffLogic_say "$ffText_errorBadUserScript" "$expression" &&
		exit $ffExitCode_internalError
	}



	# Recursively executes 'during()' on the given directory
	ffLogic_recursiveMode()
	{
		local o d=$1
		shift


		# handle files which match the target mask
		for o in "$d"/${ffOption_targetMask[$ffOptionIndex_args]:-*}; do
			local p=$o
			local n=${p##*/}

			during
		done


		# handle directories recursively
		for o in "$d"/*; do
			if [ -d "$o" ]; then

				# skip links if user has specified so
				if [ -L "$o" ] && ${ffOption_ignoreLinks[$ffOptionIndex_isOn]:-false}; then
					continue
				fi


				ffLogic_recursiveMode "$o"
			fi
		done
	}



	# Linearly executes 'during()' on the given arguments
	ffLogic_linearMode() {
		for o; do
			p=$o

			# handle special cases
			case $p in
				/)
					n=/
					d=/
					return
				;;
				.)
					n=.
					d=.
					return
				;;
				..)
					n=..
					d=.
					return
				;;

				/*|./*|../*)
					# path is already explicit
				;;

				*)
					# convert implicit relative paths into explicit relative paths
					p="./$p"
				;;
			esac


			# update preset variables
				# remove redundant slashes
				# p=${p//+(\/)//}

				# remove trailing slash
				p=${p%/}

				# keep everything after the last slash
				n=${p##*/}

				# keep everything before the last slash
				d=${d%/*}

				# special case: $d is empty when it should be /
				if [ -z "$d" ]; then
					d=/
				fi


			during
		done
	}



	# Performs upon arguments given on the pipe
	# @param	Function that will handle arguments on the pipe
	ffLogic_pipeWrapper() {
		if ${ffOption_pipeTargets[$ffOptionIndex_isOn]:-false}; then
			while read -r; do
				$1 "$REPLY"
			done
		fi
	}



	# Primary entry point into this file's logic
	ff() {
		# run the following code in a sub-shell because it uses the 'exit' command at some point. Without this sub-shell, the 'exit' command will close the user's terminal!
		(
			# dummy functions that are executed when user hasn't overridden them
			function before() { :; }
			function during() { :; }
			function after() { :; }
			function end() { :; }


			# ensure proper clean up during exit
			trap "exit $ffExitCode_systemError" INT KILL TERM HUP
			trap end EXIT


			# set options for current sub-shell
			shopt -s extglob nullglob


			# load localized bundles for current language
			ffTextBundle_$ffLanguageCode
			ffOptionBundle_$ffLanguageCode


			# parse command-line arguments
			local -a parsedArgs
			ffLogic_parseArgs parsedArgs "$@"


			# load and execute user's script
			ffLogic_loadScript

			before "${parsedArgs[@]}"

			if ${ffOption_beRecursive[$ffOptionIndex_isOn]:-false}; then
				local arg
				for arg in "${parsedArgs[@]}"; do
					ffLogic_recursiveMode "$arg"
				done

				ffLogic_pipeWrapper ffLogic_recursiveMode
			else
				ffLogic_linearMode "${parsedArgs[@]}"
				ffLogic_pipeWrapper ffLogic_linearMode
			fi

			after "${parsedArgs[@]}"

			# @note end() is automatically called by the EXIT trap
		)
	}

