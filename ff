#!/bin/bash
#
# NAME
#	ff - for each file
#	<http://freshmeat.net/projects/ff/>
#
# SYNOPSIS
#	ff [-reh] file1 file2 ... [ < script ]
#
# OPTIONS
#	-r	Handle subdirectories recursively.
#		Directories are processed before files (non-directories).
#
#	-e	Use a custom ${EDITOR} for entering scripting commands.
#		Depending on how your text editor handles I/O redirection, this
#		option may disable the ability to pipe output to other programs.
#
#	-h	Display this help message.
#
# ARGUMENTS
#	file	Path to a file (non-directory) or directory.
#
#	script	Path to an existing script file (non-directory).
#
# DESCRIPTION
#	Allows the user to execute a Bash script recursively upon many files and
#	directories. It is ideal for performing a repetitive procedure such as
#	mass file renaming. The script given by the user is interpreted directly
#	by the Bash shell.
#
#	If you wish to invoke an existing script, you can do so via piping or 
#	redirection. For example, to run a script named 'my_script' upon a 
#	directory 'dir', you would run the following.
#
#		Method 1: 	ff -r dir < my_script
#
#		Method 2:	cat my_script | ff -r dir
#
#	Notice that the '-e' option is not present. Depending on how your text
#	editor handles I/O redirection, omitting '-e' may allow you to pipe or
#	redirect input to this tool.
#
#	When an existing script is not invoked, the user will be prompted to
#	type in scripting commands in the terminal.
#	
#	If you wish enter scripting commands using your favorite text editor,
#	set a global shell variable ${EDITOR} to its path. For example, if your
#	text editor was located at '/foo/bar', you would run the following.
#	
#		declare -x EDITOR=/foo/bar
#
# SCRIPT VARIABLES
#	The following variables are available for use in users' scripts.
#
#	$fn	Basename of current file (directory or non-directory).
#
#	$f	Path of current file (directory or non-directory).
#
#	$d	Path of directory which contains current file (directory or
#		non-directory).
#
#	$w	Path of user's current working directory.
#
# AUTHORS
# 	Suraj Kurapati <skurapat@ucsc.edu>
#
# LICENSE
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or   
#	(at your option) any later version.
#

# globals
	g_tmpfileMask="/tmp/$$"
	g_tmpfile_UsrInput="${g_tmpfileMask}.UsrInput"
	g_tmpfile_Subdirs="${g_tmpfileMask}.Subdirs"
	
	# option flags
	g_options="reh"
	g_opt_recurse=r
	g_opt_editor=e
	
	# option enabled flags. enabled = 1, disabled = 0
	g_optEn_recurse=0
	g_optEn_editor=0
	
# scan options and set flags

	while getopts "$g_options" opt
	do
		case "$opt" in
			$g_opt_recurse)
				g_optEn_recurse=1
			;;
			$g_opt_editor)
				g_optEn_editor=1
			;;
			*)
				# display help message which happens to be the documentation header
				sed -e '/^$/q' -e 's/^# *//' $0 | more
				exit 0
			;;
		esac
	done
	
	
# allow user to input scripting commands
	
	if [ $g_optEn_editor -eq 1 ] && [ ! -z "$EDITOR" ] ; then
		# launch user's editor
		$EDITOR $g_tmpfile_UsrInput
	else
		# 'cat' allows piping and input redirection
		cat > $g_tmpfile_UsrInput
	fi
	
# check user script
	if [ -z "$g_tmpfile_UsrInput" ] ; then
		
		# user has aborted. clean up and exit
		rm -f ${g_tmpfileMask}*
		exit
	else
		g_input=$( cat "$g_tmpfile_UsrInput" )
	fi

# check method of operation: recursive or non-recursive

	# set scripting variable
	w="$PWD"

	if [ $g_optEn_recurse -eq 1 ] # recursive operation
	then
	
		# loop through positional params
		for param
		do
			if [ -d "$param" ] 
			then
				# assemble list of all subdirectories with the deepest sub-directories appearing first
				ls -R "$param" | grep -v '^$' | sed -n 's/:$//p' | sort -r > "$g_tmpfile_Subdirs"
				
				# determine number of subdirectories
				n=$( wc -l "$g_tmpfile_Subdirs" | awk '{ print $1 }' )
				i=1
				
				# handle each subdir
				while [ $i -le $n ]
				do
					# read subdir from file
					subdir=$( sed -n "$i p" "$g_tmpfile_Subdirs" )
					
					# check if subdir is empty
					if [ $( ls "$subdir" | wc -l ) -gt 0 ]
					then
					
						# step into subdir
						pushd "$subdir" >& /dev/null
						
							# set scripting variable
							d="$PWD"
						
							# for all files in subdir
							for f in *
							do
								# set scripting variable
								fn="$f"
								f="$d/$f"
								
								# execute user specified commands
								eval "$g_input"
							done
						
						# step out of subdir
						popd >& /dev/null
					fi
					
					# increment subdir
					let "i = i + 1"
				done
			fi
		done
	
	else # non-recursive operation
	
		# loop through positional params
		for f
		do
			# set scripting variables
			d=$( dirname "$f" )
			fn=$( basename "$f" )
			
			# execute user specified commands
			eval "$g_input"
		done
	fi
	
# cleanup
	rm -f ${g_tmpfileMask}*

