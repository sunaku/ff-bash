#!/bin/bash
#
# Command-line options parsing library.
#
###
#
# Copyright 2003, 2004 Suraj N. Kurapati.
#
###
#
# This file is part of "For each File".
# 
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###

## globals


## functions
	
	# Scans the array whose name is given by $1 for command-line options. When an option is found, the function whose name is given by $2 is invoked. If $2 does not report that the option given to it is illegal, then the option and its possible argument are then removed from the array whose name is given by $1.
	#
	# @param	1	Name of the array which contains raw command-line arguments. Once this scanOptions() function has properly terminated, the array whose name is given by $1 will contain only items that are unrelated to the command-line options.
	#
	# @param	2	Name of the function that handles option flags. The following behavior must be supported by the function whose name is given by $2:
		#
		# Handles the parsing of a command-line option.
		#
		# @param	1	option's name (flag)
		# @param	2	option's argument
		#
		# One of the following values must be returned:
		# @return	0	The given option is illegal.
		# @return	1	The given option has no argument.
		# @return	2	The given option has one argument.
		#
	# @return	0	Success.
	# @return	1	An illegal option was encountered. In the array whose name is given by $1, the name of the illegal option is stored in the first index and its possible argument is stored in the second index. The rest of the array's contents are unaccounted for.
	#
	__lib_CmdOpts_scanOptions()
	{
#		declare -a ; read < /dev/tty
		
		local i=0 j=0 k opt flag arrLen isInvalid=0
		local -a arr
		
		# make local copy of caller's array
		eval "arr=( \"\${$1[@]}\" )"
		arrLen=${#arr[@]}
		
		while (( i < arrLen ))
		do
			(( j = i + 1 ))
			
			opt=${arr[$i]}	# make a copy of the next option flag, because it may be deleted from the array before subsequent short options that it may contain are processed
			
			if [ "${opt:0:1}" == "-" ] # look for option prefix
			then
			
				if [ "${opt:1:1}" == "-" ]	# handle long option names
				then
					flag=${opt#--}
					
					"$2" "$flag" "${arr[$j]}"
					
					if ! __lib_CmdOpts_scanOptions_handleReturnValue_ $?
					then
						# illegal option encountered
						isInvalid=1
					fi
					
				else	# handle short option names
				
					# handle multiple flags that are jumbled into one option; ex: "-efm" is equivalent to "-e -f -m"
					
					k=1	# flag index; +1 to skip '-' prefix
					
					while (( k < ${#opt} ))
					do
						flag=${opt:$k:1}
						
						"$2" "$flag" "${arr[$j]}"
						
						if ! __lib_CmdOpts_scanOptions_handleReturnValue_ $?
						then
							# illegal option encountered
							isInvalid=1
							break
						fi
						
						(( k += 1 ))
					done
				fi
			fi
			
			# illegal option encountered
			if [ $isInvalid -eq 1 ]
			then
				eval "$1[0]=\$flag ; $1[1]=\${arr[$j]}"
				return 1
			fi
			
			(( i += 1 ))
		done
	
		# propogate changes in local array to caller's array
		eval "$1=( \"\${arr[@]}\" )"
		
#		declare -a ; read < /dev/tty
		return 0
	}
	
	# Handles the return value from the function whose name is given in $2 of scanOptions(). This function is meant to be used internally by this library.
	# @param	1	the return value to handle
	# @return	1	an illegal option was encountered
	__lib_CmdOpts_scanOptions_handleReturnValue_()
	{
		case "$1" in
			2)
				unset -v "arr[$j]" "arr[$i]"	# remove the option's name & argument
				
				(( j += 1 ))	# increment argument index
			;;
			
			1)
				unset -v "arr[$i]"	# remove the option's name
			;;
			
			*)
				return 1	# illegal option
		esac
		
		return 0
	}
