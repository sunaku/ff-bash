#!/bin/bash
# ff-package function library

## globals

	# shell options
	shopt -s nullglob

	# temporary files
	ff_tmpMask=${TMP:-/tmp}/ff_tmp$$
	ff_tmp_userScript=${ff_tmpMask}.script
	ff_tmp_swapFile=${ff_tmpMask}.swap
	ff_tmp_targetList=${ff_tmpMask}.list
	
	# command line options
	ff_baseOpts=ehs:t:
	ff_baseOpts_optFlg_useEditor=e
	ff_baseOpts_optFlg_showHelp=h
	ff_baseOpts_optFlg_saveInput=s
	ff_baseOpts_optFlg_targetList=t

## functions
	
	# Reads user's scripting commands from I/O redirection
	# or standard input. Also saves user's script to file.
	# @return	1	no input was given
	ff_getScript()
	{
		if [ ${ff_baseOpts_optEn_useEditor:-0} -eq 1 ] && [ ! -z "$EDITOR" ] 
		then
			# launch user's editor
			$EDITOR "$ff_tmp_userScript"
		else
			# take user input from terminal or file
			cat > "$ff_tmp_userScript"
		fi
		
		# check if no input was given
		[ ! -s "$ff_tmp_userScript" ] && return 1
		
		# save user's script to file
		if [ ${ff_baseOpts_optEn_saveInput:-0} -eq 1 ] && [ ! -z "$ff_baseOpts_optArg_saveInput" ]
		then
			cp -i "$ff_tmp_userScript" "$ff_baseOpts_optArg_saveInput" <&1
		fi
		
		return 0
	}
	
	# load user's script into RAM
	ff_evalScript()
	{
		# check if user's script uses control functions
			fgrep 'main()' "$ff_tmp_userScript" >& /dev/null
			
			# wrap user's script around main()
			if [ $? -gt 0 ]
			then
				awk "BEGIN { print \"main(){ \" } { print } END { print \"}\" }" "$ff_tmp_userScript" > "$ff_tmp_swapFile"
				mv "$ff_tmp_swapFile" "$ff_tmp_userScript"
			fi
		
		# load script into RAM
			g_input=$( cat "$ff_tmp_userScript" )
			eval "$g_input"
			g_input=
	}
	
	# clean up and exit program
	ff_exit()
	{
		# clean up temp files
		rm -f ${ff_tmpMask}*
		
		# exit with given code
		exit $1
	}
	
	# setup the list of targets which will be performed upon
	ff_setupTargets()
	{
		# use user's target list if specified
		if [ ${ff_baseOpts_optEn_targetList:-0} -eq 1 ] && [ ! -z "$ff_baseOpts_optArg_targetList" ]
		then
			cp "$ff_baseOpts_optArg_targetList" "$ff_tmp_targetList"
		else
			# write command line arguments to target list
			ls -d "${@}" > "$ff_tmp_targetList"
		fi
	}
	
	# scan base options and set flags
	# @return 	5 	if user asked to see help message
	#		1	illegal option
	# @param	$1	command line option flag to handle
	ff_handleBaseOption()
	{
		case $1 in
			$ff_baseOpts_optFlg_useEditor)
				ff_baseOpts_optEn_useEditor=1
			;;
			$ff_baseOpts_optFlg_targetList)
				ff_baseOpts_optEn_targetList=1
				ff_baseOpts_optArg_targetList=$OPTARG
			;;
			$ff_baseOpts_optFlg_saveInput)
				ff_baseOpts_optEn_saveInput=1
				ff_baseOpts_optArg_saveInput=$OPTARG
			;;
			$ff_baseOpts_optFlg_showHelp)
				# display help message which happens to be the documentation header of this file
				sed -e '1d' -e '/^$/q' -e 's/^# *//' $0 | more
				return 5
			;;
			*)
				return 1
			;;
		esac
		
		return 0
	}

