#!/bin/bash
# ff-package function library

## globals

	# shell options
	shopt -s nullglob

	# temporary files
	ff_tmpMask=${TMP:-/tmp}/ff_tmp$$
	ff_tmp_userScript=${ff_tmpMask}.script
	ff_tmp_swapFile=${ff_tmpMask}.swap
	
	# command line options
	ff_baseOpts=ehs:t:
	ff_baseOpts_optFlg_useEditor=e
	ff_baseOpts_optFlg_showHelp=h
	ff_baseOpts_optFlg_saveInput=s
	ff_baseOpts_optFlg_targetList=t
	
	# targets
	declare -a ff_targetArray

## functions
	
	# Reads user's scripting commands from I/O redirection
	# or standard input. Also saves user's script to file.
	# @return	1	no input was given
	ff_getScript()
	{
		if [ ${ff_baseOpts_optEn_useEditor:-0} -eq 1 ] && [ ! -z "$EDITOR" ] 
		then
			# launch user's editor
			$EDITOR "$ff_tmp_userScript"
		else
			# take user input from terminal or file
			cat > "$ff_tmp_userScript"
		fi
		
		# check if no input was given
		[ ! -s "$ff_tmp_userScript" ] && return 1
		
		# save user's script to file
		if [ ${ff_baseOpts_optEn_saveInput:-0} -eq 1 ] && [ ! -z "$ff_baseOpts_optArg_saveInput" ]
		then
			cp -i "$ff_tmp_userScript" "$ff_baseOpts_optArg_saveInput" <&1
		fi
		
		return 0
	}
	
	# load user's script into RAM
	ff_evalScript()
	{
		# check if user's script uses control functions
			fgrep 'main()' "$ff_tmp_userScript" >& /dev/null
			
			# wrap user's script around main()
			if [ $? -gt 0 ]
			then
				awk "BEGIN { print \"main(){ \" } { print } END { print \"}\" }" "$ff_tmp_userScript" > "$ff_tmp_swapFile"
				mv "$ff_tmp_swapFile" "$ff_tmp_userScript"
			fi
		
		# load script into RAM
			g_input=$( < "$ff_tmp_userScript" )
			eval "$g_input"
			g_input=
	}
	
	# clean up and exit program
	ff_exit()
	{
		# clean up temp files
		rm -f ${ff_tmpMask}*
		
		# exit with given code
		exit $1
	}
	
	# setup the list of targets which will be performed upon
	ff_setupTargets()
	{
		if [ ${ff_baseOpts_optEn_targetList:-0} -eq 1 ] && [ -n "$ff_baseOpts_optArg_targetList" ]
		then
			# use targets listed in a file
			local line
			
			while read line
			do
				ff_targetArray[${#ff_targetArray[@]}]=$line
			done < "$ff_baseOpts_optArg_targetList"
		else
			# use targets given on command line
			ff_targetArray=( "${@}" )
		fi
	}
	
	# scan base options and set flags
	# @return 	5 	if user asked to see help message
	#		1	illegal option
	# @param	$1	command line option flag to handle
	ff_handleBaseOption()
	{
		case $1 in
			$ff_baseOpts_optFlg_useEditor)
				ff_baseOpts_optEn_useEditor=1
			;;
			$ff_baseOpts_optFlg_targetList)
				ff_baseOpts_optEn_targetList=1
				ff_baseOpts_optArg_targetList=$OPTARG
			;;
			$ff_baseOpts_optFlg_saveInput)
				ff_baseOpts_optEn_saveInput=1
				ff_baseOpts_optArg_saveInput=$OPTARG
			;;
			$ff_baseOpts_optFlg_showHelp)
				# display help message which happens to be the documentation header of this file
				sed -e '1d' -e '/^$/q' -e 's/^# *//' $0 | more
				return 5
			;;
			*)
				return 1
			;;
		esac
		
		return 0
	}
	
	# base application logic
	ff_baseLogic()
	{
		# ensures proper clean up
			trap 'ff_exit' INT EXIT
		
		# scan command line options
			
			ff_scanOptions "${@}"
			
			# exit if help message was displayed or illegal options were given
			[ $? -gt 0 ] && ff_exit
	
		# get user's script & save it
	
			ff_getScript
	
			# exit if no script was given
			[ $? -gt 0 ] && ff_exit
	
		# handle user's script
	
			# load script into RAM
			ff_evalScript
	
			# generate list of targets to perform upon
			ff_setupTargets "${@}"
			
			# execute script
			ff_main
	
		# finished
	}

