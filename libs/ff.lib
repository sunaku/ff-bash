#!/bin/bash
#
# Common function library for 'ff' and 'fl' tools.
#
# Dependencies:
#
# 	${__ff_myHome}*		path to installation directory
#
###
#
# Copyright 2003, 2004 Suraj N. Kurapati.
#
###
#
# This file is part of "For each File".
#
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###

## globals

	__lib_ff_version_number=1.7.3
	__lib_ff_version_date=2004-09-10

	declare -a __lib_ff_targetList __lib_ff_scriptArgs

	# command line options
		__lib_ff_options_shortFlag_evalExpr=-e
		__lib_ff_options_longFlag_evalExpr=--expression

		__lib_ff_options_shortFlag_evalFile=-f
		__lib_ff_options_longFlag_evalFile=--file

		__lib_ff_options_shortFlag_readPipe=-p
		__lib_ff_options_longFlag_readPipe=--pipe
		__lib_ff_options_flag_pipeDelim=--pipe-delim

		__lib_ff_options_flag_showHelp=--help
		__lib_ff_options_flag_showVersion=--version
		__lib_ff_options_flag_endOpts=--
		__lib_ff_options_flag_scriptArgs=--args
		__lib_ff_options_flag_language=--lang


## libraries
	source "$__ff_myResources_libs/gettext.lib"
	source "$__ff_myResources_libs/util.lib"
	source "$__ff_myResources_libs/CmdOpts.lib"

## functions

	__lib_ff_loadI18N()
	{
		__lib_gettext_clear
		__lib_gettext_load "${__ff_myResources_i18n}"/*."${__ff_myLang}.po"
	}

	# load user's script into RAM
	__lib_ff_loadScript()
	{
		local expression=":;"

		# store input

			if [ ${__lib_ff_options_isOn_evalExpr:-0} -eq 1 ]
			then
				# read command-line argument
				expression=$__lib_ff_options_value_evalExpr
			elif [ ${__lib_ff_options_isOn_evalFile:-0} -eq 1 ]
			then
				# read script file
				if [[ -f "$__lib_ff_options_value_evalFile" && -r "$__lib_ff_options_value_evalFile" ]]
				then
					expression=$( < "$__lib_ff_options_value_evalFile" )
				else
					gettext "Error: Unable to read script-file %s." "\"$__lib_ff_options_value_evalFile\""
					exit 2
				fi
			else
				# read from user's terminal
				while IFS= read -er < /dev/tty
				do
					expression="$expression
$REPLY"
				done
			fi

		# check input for control functions

			if [[ -n "${expression/*main*( |	)\(*( |	)\)*/}" && -n "${expression/*function+( |	)main*/}" ]]
			then
				expression="
main(){
$expression
:;}"
			fi

		# load script into RAM
			eval "$expression"
	}

	# handles parsing of common command-line options
	# @see __lib_CmdOpts_handleOption()
	__lib_ff_handleBaseOption()
	{
		case $1 in
			$__lib_ff_options_shortFlag_evalExpr | $__lib_ff_options_longFlag_evalExpr)
				__lib_ff_options_isOn_evalExpr=1
				__lib_ff_options_value_evalExpr=$2
				return 2
			;;
			$__lib_ff_options_shortFlag_evalFile | $__lib_ff_options_longFlag_evalFile)
				__lib_ff_options_isOn_evalFile=1
				__lib_ff_options_value_evalFile=$2
				return 2
			;;
			$__lib_ff_options_shortFlag_readPipe | $__lib_ff_options_longFlag_readPipe)
				__lib_ff_options_isOn_readPipe=1
				return 1
			;;
			$__lib_ff_options_flag_pipeDelim)
				__lib_ff_options_isOn_pipeDelim=1
				__lib_ff_options_value_pipeDelim=$2
				return 2
			;;
			$__lib_ff_options_flag_showHelp)

				local __lib_ff_docFileName=manual __lib_ff_docLang=$__ff_myLang __lib_ff_docI18n __lib_ff_docCached
				local __lib_ff_docFilePath="$__ff_myResources_docs/$__lib_ff_docFileName"

				# NOTE: there are no translation catalogs for English because the documentation is written in English

				# determine which translation catalog to use
					[ -n "$2" ] && __lib_ff_docLang=${2:0:2}	# parse user's choice
					__lib_ff_docI18n="$__ff_myResources_i18n/$__lib_ff_docFileName.$__lib_ff_docLang.po"

				# check if the chosen translation catalog is available
					if ! [ -r "$__lib_ff_docI18n" -a -f "$__lib_ff_docI18n" ]
					then
						if [ -n "${__lib_ff_docLang/*+(en|C|POSIX)*/}" ]	# check for English's language code equivalencies
						then
							gettext "Error: Unable to read the translation catalog for language code %s." "\"$__lib_ff_docLang\""

							__lib_util_queryYesNo "$( gettext "Would you like to view the documentation in English?" )" 1 && exit
						fi

						__lib_ff_docLang=en
					fi

				# display the documentation

					__lib_ff_docCached="$__ff_myConf/$__ff_myName.$__lib_ff_docFileName.$__lib_ff_docLang"	# cached copies are stored in user settings directory

					{
						if [[ -e "$__lib_ff_docCached" && "$__lib_ff_docFilePath" -ot "$__lib_ff_docCached" && "$__lib_ff_docI18n" -ot "$__lib_ff_docCached" ]]	# check for previously cached documentation
						then
							cat "$__lib_ff_docCached"	# display cached file
						else
							# load dependencies
							source "$__ff_myResources_libs/DocFmt.lib"
							__lib_gettext_load "$__lib_ff_docI18n"

							# generate & cache the documentation
							source "$__lib_ff_docFilePath" | __lib_DocFmt_formatTags | tee "$__lib_ff_docCached"
						fi
					} | expand -t 4 | fmt -w ${COLUMNS:-80} | ${PAGER:-less -r}

				exit
			;;
			$__lib_ff_options_flag_showVersion)
				echo -e "$__lib_ff_version_number\t$__lib_ff_version_date"
				exit
			;;
			$__lib_ff_options_flag_language)
				if [ -n "$2" ]
				then
					__ff_myLang=$2
					__lib_ff_loadI18N	# reload I18N catalogs
				fi
				return 2
			;;
			$__lib_ff_options_flag_endOpts)
				return 255
			;;
			$__lib_ff_options_flag_scriptArgs)
				flag=__lib_ff_scriptArgs
				return 254
			;;
		esac

		return 0
	}

	# updates the values of preset variables during non-recursive mode
	__lib_ff_updateVars_linear()
	{
		p=$o

		# handle special cases
		case "$p" in
			/)
				n=/
				d=/
				return
			;;
			.)
				n=.
				d=.
				return
			;;
			..)
				n=..
				d=.
				return
			;;

			/*|./*|../*) ;;	# path is already explicit

			*)
				p="./$p" # make implicit relative paths explicit
			;;
		esac

		# update preset variables
		p=${p//+(\/)//}	# remove redundant slashes
		p=${p%/}	# remove trailing slash
		n=${p##*/}	# keep everything after the last slash
		d=${p%/*}	# keep everything before the last slash
		[ -z "$d" ] && d=/	# special case: $d is empty when it should be /
	}

	# base application logic
	__lib_ff_main()
	{
		# ensures proper clean up
			trap 'exit 255' INT KILL TERM HUP
			trap 'finalize' EXIT	# call clean-up routines in user's script

		# set behavior of current sub-shell
			shopt -s nullglob extglob interactive_comments
			shopt -u cmdhist

		# load resources
			__lib_ff_loadI18N	# translation catalogs

		# scan command line options

			# NOTE: assuming '$__lib_ff_targetList' is already initialized by the client script of this library
			if ! __lib_CmdOpts_scanOptions __lib_ff_targetList __lib_ff_handleOption
			then
				gettext "Error: %s is not a valid option. Try %s." "\"${__lib_ff_targetList[0]}\"" "\"$__lib_ff_options_flag_showHelp\""
				exit 1
			fi

		# load and execute script
			__lib_ff_loadScript
			__ff_main	# invoke the client script that is currently using this library
	}

