#!/bin/bash
#
# gettext emulation library.
#
###
#
# Copyright 2003-2004 Suraj N. Kurapati.
#
###
#
# This file is part of "For each File".
# 
# "For each File" is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# "For each File" is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with "For each File"; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
###


## globals

	__lib_gettext_tempfile="${TMP:-/tmp}/__lib_gettext.$$"
	__lib_gettext_tempfile_cacheIndex="$__lib_gettext_tempfile.index"
	
	# even index: msgid
	# odd index: msgstr
	declare -a __lib_gettext_cache
	
## functions
	
	# Initializes internal library structures
	# This function must be invoked before using any other the library functions
	__lib_gettext_init()
	{
		# setup shared cacheIndex
		echo 0 > "$__lib_gettext_tempfile_cacheIndex"
	}
	
	# Performs clean up of internal library structures
	# This function must be invoked before exiting the program
	__lib_gettext_fin()
	{
		# free memory
		__lib_gettext_free
		
		# clean up temp files
		rm -f ${__lib_gettext_tempfile}*
	}

	# Loads a gettext Portable-Object translation catalog into cache.
	# Cache is not cleared before loading new data.
	#
	# @usage	__lib_gettext_load FILE...
	#
	# @param	FILE	Path of Portable-Object file to load.
	#
	# @return	Standard UNIX exit status.
	#
	# Catalog file Requirements
	# ----------------------------------
	# +	Strings should be properly quoted, using double quotes. 
	#	For example:
	#
	#		msgid "hello world"
	#		msgstr ""
	#
	# +	Multi-line strings are also supported.
	#	For example:
	#
	#		msgstr "This"
	#		  "spans multiple lines"
	#		  "..."
	#
	#	And this:
	#		msgstr "This
	#		  spans multiple lines
	#		  ..."
	#
	# -------------------------------------
	#
	__lib_gettext_load()
	{
		# variables
		local file line exit_status=0
		
		# parse catalog files
		for file
		do
			# check file perms
			if [[ ! -r "$file" || ! -f "$file" ]]
			then
				exit_status=1
				continue
			fi
			
			# get all strings onto one line
			sed -e '/^$/d' -e '/^ *\#/d' "$file" | tr '\n' ' ' | sed -e 's/\([^\\]\)" *\([^\\]\)"/\1 \2/g' -e 's/msg[si][td]r\?  */\n/g' | sed -e '1d' -e 's/^ *"//' -e 's/" *$//' > "$__lib_gettext_tempfile"
			echo -e '\n' >> "$__lib_gettext_tempfile"
			
			# load file
			while read -r line
			do
				__lib_gettext_cache[${#__lib_gettext_cache[@]}]=$line
			done < "$__lib_gettext_tempfile"
			
			# ensure there are even number of items in cache
			(( ${#__lib_gettext_cache[@]} % 2 != 0 )) && unset -v __lib_gettext_cache[$(( ${#__lib_gettext_cache[@]} - 1 ))]
			
#			declare -a ; read -u 2
		done
		
		# clean up
		rm -f "$__lib_gettext_tempfile"
		
		return $exit_status
	}
	
	
	# parsing state machine:: VERY SLOW!
#	__lib_gettext_load_stateMachine()
#	{
#		# read words for current string
#		if [ "$state" == read ]
#		then
#			# conditions that stop from reading
#			if [[ "$word" == "msgid" || "$word" == "msgstr" ]]
#			then
#				# note: new string_type is in $word
#				
#				# state changes
#				state=setup
#				
#			elif [ ! -z "$string_type" ]
#			then
#				# determine quote
#				if [ -z "$string_quote" ]
#				then
#					string_quote=${word:0:1}
#				else
#					# strip multi-line quotes
#					if [[ "$string" != "${string%$string_quote}" && "$string_quote" == ${word:0:1} ]]
#					then
#						string=${string%$string_quote}
#						word=${word#$string_quote}
##						echo ">>> stripping multi-line quote"
#					fi
#				fi
#				
#				# accumulate string 
#				string="$string $word"	# note: this adds initial space at start of string
#				
#			fi
#		fi
#		
#		# setup variables for next string
#		if [ "$state" == setup ]
#		then
#		
#			# process data
#			string=${string# }		# remove initial space added during first accumulation
#			string=${string#$string_quote}	# strip bounding quotes
#			string=${string%$string_quote}
#		
#			# store data
#			if [ "$string_type" == "msgid" ]
#			then
#				__lib_gettext_cache_msgid[${#__lib_gettext_cache_msgid[@]}]=$string
#			elif [ "$string_type" == "msgstr" ]
#			then
#				__lib_gettext_cache_msgstr[${#__lib_gettext_cache_msgstr[@]}]=$string
#			fi
#			
#			# reset vars
#			string=
#			string_type=$word
#			string_quote=
#			
#			# state changes
#			state=read
#		fi
#	}
	
	# Frees cached translation catalog data from memory.
	__lib_gettext_free()
	{
		unset __lib_gettext_cache
	}
	
	
	# Prints a translated string using the loaded catalog data.
	# If a translation is not available, the given query is printed.
	# Escaped sequences such as '\n' are automatically expanded.
	#
	# @see		printf
	#
	# @usage	gettext [OPTION] [QUERY] [ARGUMENT]...
	#
	# @option	-n	Suppress trailing newline.
	#
	# @param	$1	QUERY to translate. This string can have
	#			placeholders which are prefixed with '%' the
	#			percent symbol.
	#
	# @param	...	A variable number of arguments which denote
	#			values for placeholders in both the translated
	#			string and the string to be translated.
	#
	# @return	Standard UNIX exit status.
	#
	gettext()
	{
		local query translation cacheIndex=$( < "$__lib_gettext_tempfile_cacheIndex" )
		
#		echo "__lib_gettext_tempfile_cacheIndex=$__lib_gettext_tempfile_cacheIndex"
#		cat $__lib_gettext_tempfile_cacheIndex
		
		# handle options
		
			if [ "$1" == "-n" ]
			then
				__lib_gettext_options_isOn_noNewline=1
				shift	# remove $1
			fi
			
		# locate query in catalog cache
		
			query=$1
			shift	# remove $1 from parameters
		
			# check index bounds
			[ $cacheIndex -ge ${#__lib_gettext_cache[@]} ] && cacheIndex=0
			
			while [ $cacheIndex -lt ${#__lib_gettext_cache[@]} ]
			do
				[ "$query" == "${__lib_gettext_cache[$cacheIndex]}" ] && break
				let cacheIndex=cacheIndex+2	# increment loop
			done
			
			let string_index=cacheIndex+1
			
#			echo "cacheIndex=$cacheIndex"
#			echo "cache size=${#__lib_gettext_cache_msgid[@]}"
#			echo "msgstr='${__lib_gettext_cache_msgstr[$cacheIndex]}'"
			
		# determine translation
		
			if [ ! -z "${__lib_gettext_cache[$string_index]}" ]
			then
				translation=${__lib_gettext_cache[$string_index]}
			else
				# translation is blank. use untranslated query.
				translation=$query
			fi
		
		# print result
		
			# add trailing newline
			[ ${__lib_gettext_options_isOn_noNewline:-0} -eq 0 ] && translation=${translation}\\n
			
			printf "${translation}" "${@}"
			
		# finished
		echo $cacheIndex > "$__lib_gettext_tempfile_cacheIndex"
#		cat "$__lib_gettext_tempfile_cacheIndex"
		return 0
	}
	
	# function alias
	eval_gettext()
	{
		gettext "${@}"
	}
	
	# function alias 
	eval_ngettext()
	{
		ngettext "${@}"
	}
