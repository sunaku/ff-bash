#!/bin/bash
# gettext emulation library (gte)
# Provides BASH functions which emulate the GNU "gettext" program.
# Note: all library variables begin with an underscore
#
# This file is distributed under the same license as the "ff" package.



## globals

	_gte_tempfile=${TMP:-/tmp}/$$
	
	# arrays to cache the catalog data
	declare -a _gte_cache_msgid _gte_cache_msgstr
	
	# options for gettext()
	_gte_gettext_opts=n
	_gte_gettext_optFlg_noNewline=n
	
## functions
	
	# Loads a gettext Portable-Object translation catalog into cache.
	# Cache is not cleared before loading new data.
	#
	# @usage	_gte_load FILE
	#
	# @param	FILE	Path of Portable-Object file to load.
	#
	# @return	Standard UNIX exit status.
	#
	# Catalog file Requirements
	# ----------------------------------
	# +	Strings should be properly quoted. For example:
	#
	#		msgid "hello world"
	#		msgstr ""
	#
	# +	Multi-line strings are not supported. You must use '\n' instead.
	#	For example, instead of this:
	#
	#		msgstr "This"
	#		  "spans multiple lines"
	#		  "..."
	#
	#	Use this:
	#		msgstr "This\nspans multiple lines\n..."
	#
	# -------------------------------------
	#
	_gte_load()
	{
		# check arguments
		[[ ! -r "$1" || ! -f "$1" ]] && return 1
		
		# parse catalog file
		
			# write entries to file because problems when piping output to 'while read'
			sed -n 's/^msg\([is][dt]r\?\) *\(.*\)$/\1 \2/p' "$1" > "$_gte_tempfile"
			
			# load string values of entries into cache
			while read str
			do
#				echo "key='${str%% *}'"
#				echo "value='${str#* }'"
#				echo "index=${#_gte_cache_msgid[@]}"
				
				case ${str%% *} in
					id)
						_gte_cache_msgid[${#_gte_cache_msgid[@]}]=${str#* }
					;;
					str)
						_gte_cache_msgstr[${#_gte_cache_msgstr[@]}]=${str#* }
					;;
				esac
				
			done < "$_gte_tempfile"
			
			# clean up
			rm -f "$_gte_tempfile"
			
		# finished
		return 0
	}
	
	# Frees cached translation catalog data from memory.
	_gte_free()
	{
		unset _gte_cache_msgid
		unset _gte_cache_msgstr
	}
	
	
	# Prints a translated string using the loaded catalog data.
	# If a translation is not available, the given query is printed.
	# Escaped sequences such as '\n' are automatically expanded.
	#
	# @see		printf
	#
	# @usage	gettext [OPTION] [QUERY] [ARGUMENT]...
	#
	# @option	-n	Suppress trailing newline.
	#
	# @param	$1	QUERY to translate. This string can have
	#			placeholders which are prefixed with '%' the
	#			percent symbol.
	#
	# @param	...	A variable number of arguments which denote
	#			values for placeholders in both the translated
	#			string and the string to be translated.
	#
	# @return	Standard UNIX exit status.
	#
	gettext()
	{
		local cache_index=0 query="\"$1\"" translation
		
		shift	# remove $1 from parameters
		
		# handle options
		
			while getopts $_gte_gettext_opts opt
			do
				case $opt in
					$_gte_gettext_optFlg_noNewline)
						_gte_gettext_optEn_noNewline=1
						shift	# remove from args
					;;
				esac
			done
		
		# locate query in catalog cache
		
			while [ $cache_index -lt ${#_gte_cache_msgid[@]} ]
			do
				[ "$query" == "${_gte_cache_msgid[$cache_index]}" ] && break
				let cache_index=cache_index+1	# increment loop
			done
			
#			echo "cache_index=$cache_index"
#			echo "cache size=${#_gte_cache_msgid[@]}"
			
			
		# determine translation
		
			if [ ! -z "${_gte_cache_msgstr[$cache_index]}" ]
			then
				translation=${_gte_cache_msgstr[$cache_index]}
			else
				# translation is blank. use untranslated query.
				translation=$query
			fi
		
		# print result
		
			# strip bounding quotes before printing
			translation=${translation#\"}
			translation=${translation%\"}
			
			printf "${translation}${_gte_gettext_optEn_noNewline:-\n}" "${@}"
			
		# finished
		return 0
	}
	
